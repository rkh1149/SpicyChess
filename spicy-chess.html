<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Spicy Chess — Mild/Medium/Chaotic</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- tiny inline favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><text y='14' font-size='14'>♟️</text></svg>">
  <!-- Local dependencies for offline/self-contained operation -->
  <script src="./vendor/jquery.min.js"></script>
  <link rel="stylesheet" href="./vendor/chessboard-0.3.0.min.css" />
  <script src="./vendor/chessboard-0.3.0.min.js"></script>
  <script src="./vendor/chess.min.js"></script>
  <style>
    :root {
      --bg0: #fcfbf6;
      --bg1: #efe7d7;
      --ink: #17212f;
      --ink-soft: #4f5d72;
      --line: #d5dbe4;
      --accent: #ca8b30;
      --accent-soft: rgba(202, 139, 48, 0.2);
      --ok: #2f9e44;
      --warn: #d9480f;
      --board-size: 480px;
    }
    body {
      font-family: "Avenir Next", "Gill Sans", "Trebuchet MS", sans-serif;
      color: var(--ink);
      margin: 12px;
      background:
        radial-gradient(circle at 10% 10%, rgba(255,255,255,0.8), transparent 45%),
        linear-gradient(145deg, var(--bg0), var(--bg1));
    }
    h2 { margin: 8px 8px 10px; letter-spacing: 0.2px; }
    #appLayout {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    #controls { display:inline-block; vertical-align:top; margin-left:8px; max-width:460px; min-width:340px; }
    .panel {
      border: 1px solid var(--line);
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.82);
      box-shadow: 0 2px 10px rgba(23, 33, 47, 0.08);
    }
    .panel h3 { margin: 0 0 8px; font-size: 0.95rem; letter-spacing: 0.4px; text-transform: uppercase; color: var(--ink-soft); }
    button {
      margin: 4px 6px 4px 0;
      padding: 8px 12px;
      cursor: pointer;
      border: 1px solid #bfc7d4;
      border-radius: 8px;
      background: linear-gradient(180deg, #fff, #eef2f7);
      color: var(--ink);
    }
    button:hover { filter: brightness(0.98); }
    .primary-btn { background: linear-gradient(180deg, #fdf0da, #f2d7a8); border-color: #d8b681; }
    select {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #c8ced9;
      background: #fff;
      min-width: 140px;
    }
    .note { font-size: 0.9rem; color: var(--ink-soft); margin-top: 6px; }
    #log { height: 220px; overflow:auto; background:white; padding:8px; border-radius:8px; border:1px solid #e3e8ef; font-family: "IBM Plex Mono", "Menlo", "Consolas", monospace; font-size: 12px; }
    #logDetails summary { cursor: pointer; font-weight: 600; margin-bottom: 8px; }
    [data-square].hl { outline:3px solid var(--accent); outline-offset: -3px; }

    /* Board size (inner board area) */
    #board { width: var(--board-size); height: var(--board-size); display:inline-block; vertical-align:top; touch-action: manipulation; }

    /* Fallback styles in case Chessboard.js CSS fails to load (matches v0.3.0) */
    .chessboard-63f37 { border: 2px solid #333; box-sizing: border-box; }
    .board-b72b1 { position: relative; width: 100%; height: 100%; }
    .square-55d63 { float: left; width: 12.5%; height: 12.5%; box-sizing: border-box; background-position: center center; background-repeat: no-repeat; background-size: contain; transition: filter 120ms ease, box-shadow 140ms ease; }
    .white-1e1d7 { background-color: #f0d9b5; }
    .black-3c85d { background-color: #b58863; }
    .clearfix-7da63:after { content: ""; display: table; clear: both; }

    /* === Coordinate frame outside the board === */
    .board-frame {
      display: inline-block;
      padding: 10px;
      border: 2px solid #414b5f;
      border-radius: 12px;
      background: rgba(255,255,255,0.9);
      vertical-align: top;
      margin: 8px;
      box-shadow: 0 8px 24px rgba(23, 33, 47, 0.12);
      position: relative;
    }
    .board-actions { margin-top: 8px; text-align: center; }
    .board-action-row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 8px; }
    #touchHint {
      margin-top: 8px;
      font-size: 0.78rem;
      color: #4b5a72;
      background: #f8fbff;
      border: 1px solid #d7e4f5;
      border-radius: 8px;
      padding: 6px 8px;
    }
    #eloBoardPanel {
      margin-top: 8px;
      border: 1px solid #d4dce8;
      border-radius: 10px;
      background: rgba(255,255,255,0.96);
      padding: 8px 10px;
      text-align: left;
      font-size: 0.82rem;
      color: #3e4d66;
    }
    #eloBoardPanel strong { color: #24324a; }
    #eloSummary { margin-top: 4px; color: #5d6d87; font-size: 0.78rem; }
    #boardWrap {
      display: grid;
      grid-template-columns: 32px var(--board-size);
      grid-template-rows: var(--board-size) 32px;
      gap: 0;
      align-items: stretch;
      position: relative;
    }
    #rankLabels { grid-column: 1; grid-row: 1; display: flex; flex-direction: column-reverse; }
    #rankLabels div { height: 12.5%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #2f3a4c; user-select: none; }
    #fileLabels { grid-column: 2; grid-row: 2; display: flex; flex-direction: row; }
    #fileLabels div { width: 12.5%; text-align: center; line-height: 32px; font-weight: 700; color: #2f3a4c; user-select: none; }
    #corner { grid-column: 1; grid-row: 2; }

    #statusBar {
      margin: 0 8px 10px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(255,255,255,0.86);
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .badge {
      display: inline-block;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid #c8d0dc;
      font-size: 0.84rem;
      background: #f4f7fb;
      color: #2f3a4c;
    }
    .badge.state-check { background: #ffe8cc; border-color: #ffc078; color: #8a4300; }
    .badge.state-win { background: #e6fcf5; border-color: #8ce99a; color: #1b5e20; }
    .badge.state-draw { background: #edf2ff; border-color: #bac8ff; color: #364fc7; }
    .status-sep { color: #97a1b4; }

    .control-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .control-item label { display: block; font-weight: 700; font-size: 0.84rem; margin-bottom: 4px; color: #2c3850; }
    #assetCheckResult {
      min-height: 22px;
      padding: 6px 8px;
      border: 1px solid #d7e4f5;
      border-radius: 8px;
      background: #f8fbff;
      color: #3f4f67;
      font-size: 0.82rem;
      line-height: 1.25;
      word-break: break-word;
    }
    #assetCheckResult.asset-ok {
      border-color: #a9d8b2;
      background: #effcf3;
      color: #1e6a35;
      font-weight: 700;
    }
    #assetCheckResult.asset-missing {
      border-color: #efc0b7;
      background: #fff5f2;
      color: #8f2d1d;
    }
    .action-row { margin-top: 10px; }

    #capturePanel { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px; }
    .capture-box { border: 1px solid #dde3ed; background: #fff; border-radius: 8px; padding: 8px; }
    .capture-title { font-size: 0.78rem; font-weight: 700; color: #5b6c86; letter-spacing: 0.3px; text-transform: uppercase; }
    .capture-list { margin-top: 4px; min-height: 22px; font-size: 1.05rem; letter-spacing: 1px; }
    #materialWrap { margin-top: 10px; }
    #materialLabel { font-size: 0.82rem; color: #4b5a72; margin-bottom: 4px; }
    #materialBar {
      height: 12px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #ccd4e0;
      background: #e9edf4;
      position: relative;
    }
    #materialFill {
      height: 100%;
      width: 50%;
      background: linear-gradient(90deg, #4f8fdf, #8fc1ff);
      transition: width 220ms ease;
    }
    #clockPanel { margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .clock-box {
      border: 1px solid #d8e0ec;
      border-radius: 8px;
      padding: 6px 8px;
      background: #fff;
    }
    .clock-label { font-size: 0.78rem; color: #5f6f87; text-transform: uppercase; letter-spacing: 0.2px; }
    .clock-time { font-family: "IBM Plex Mono", "Menlo", "Consolas", monospace; font-size: 1.02rem; color: #2a3953; }
    .clock-box.active { border-color: #87b0e9; box-shadow: inset 0 0 0 2px rgba(106, 157, 226, 0.2); }
    #moveHistoryList {
      max-height: 220px;
      overflow: auto;
      border: 1px solid #e3e8ef;
      border-radius: 8px;
      background: #fff;
      padding: 6px;
      font-family: "IBM Plex Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
    }
    .move-row { display: grid; grid-template-columns: 34px 1fr 1fr; gap: 6px; padding: 2px 0; align-items: center; }
    .move-num { color: #657792; }
    .move-btn {
      border: 1px solid #d7dfea;
      border-radius: 6px;
      background: #f8fafe;
      padding: 2px 6px;
      text-align: left;
      font-size: 12px;
      margin: 0;
    }
    .move-btn:hover { background: #eef4fd; }
    #moveHistoryActions { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }

    [data-square].sq-last-from { box-shadow: inset 0 0 0 4px rgba(68, 114, 196, 0.55); }
    [data-square].sq-last-to { box-shadow: inset 0 0 0 4px rgba(69, 166, 98, 0.58); }
    [data-square].sq-legal { box-shadow: inset 0 0 0 3px rgba(202, 139, 48, 0.52); filter: brightness(1.03); }
    [data-square].sq-check { animation: checkPulse 900ms ease-in-out infinite; }
    [data-square].sq-demo-from { box-shadow: inset 0 0 0 4px rgba(30, 136, 229, 0.85); }
    [data-square].sq-demo-to { box-shadow: inset 0 0 0 4px rgba(255, 143, 0, 0.9); }
    [data-square].sq-hint-from { box-shadow: inset 0 0 0 4px rgba(43, 108, 196, 0.9); }
    [data-square].sq-hint-to { box-shadow: inset 0 0 0 4px rgba(15, 147, 115, 0.9); }
    .hint-from-text { color: #2b6cc4; font-weight: 700; }
    .hint-to-text { color: #0f8f73; font-weight: 700; }
    @keyframes checkPulse {
      0% { box-shadow: inset 0 0 0 2px rgba(217, 72, 15, 0.35); }
      50% { box-shadow: inset 0 0 0 5px rgba(217, 72, 15, 0.75); }
      100% { box-shadow: inset 0 0 0 2px rgba(217, 72, 15, 0.35); }
    }
    .piece-417db { transition: transform 130ms ease, filter 130ms ease; }
    .board-b72b1:hover .piece-417db { filter: drop-shadow(0 1px 2px rgba(0,0,0,0.18)); }

    #demoOverlay {
      position: fixed;
      top: 84px;
      left: 16px;
      width: min(360px, calc(100vw - 24px));
      z-index: 12;
      display: none;
      pointer-events: none;
    }
    #demoOverlay.show { display: block; }
    #demoOverlayCard {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.97);
      border: 1px solid #cbd4e2;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 10px 28px rgba(17, 24, 39, 0.22);
    }
    #demoOverlayTitle { margin: 0 0 6px; font-size: 0.95rem; }
    #demoOverlayTitle.demo-drag-handle { cursor: move; user-select: none; }
    #demoOverlayBody { margin: 0 0 6px; font-size: 0.88rem; color: #3f4f67; }
    #demoOverlayMove { margin: 0 0 8px; font-size: 0.82rem; color: #566786; font-family: "IBM Plex Mono", "Menlo", "Consolas", monospace; }
    #demoOverlayQuestion { margin: 0 0 8px; font-size: 0.86rem; font-weight: 700; color: #2f3a4c; }
    #demoOverlayActions { display: flex; gap: 8px; }
    #demoYesBtn, #demoNoBtn { min-width: 72px; }

    #endgameOverlay {
      position: absolute;
      left: 42px;
      top: calc(var(--board-size) * 0.3);
      width: min(360px, calc(var(--board-size) - 20px));
      z-index: 11;
      display: none;
      pointer-events: none;
    }
    #endgameOverlay.show { display: block; }
    #endgameOverlayCard {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.96);
      border: 1px solid #cdd7e6;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 10px 28px rgba(17, 24, 39, 0.2);
    }
    #endgameOverlayTitle { margin: 0 0 6px; font-size: 0.95rem; }
    #endgameOverlayBody { margin: 0; font-size: 0.86rem; color: #3f4f67; }

    /* Hide Chessboard.js internal coordinates (if injected) */
    .notation-322f9, .alpha-d2270, .numeric-fc462 { display: none !important; }

    @media (max-width: 980px) {
      :root { --board-size: min(86vw, 480px); }
      #appLayout { flex-direction: column; align-items: stretch; }
      #controls { max-width: none; min-width: 0; margin-left: 8px; margin-right: 8px; }
      .board-frame { margin: 8px; width: fit-content; max-width: 100%; }
      .control-grid { grid-template-columns: 1fr; }
    }
  </style>
  <!-- Load local Stockfish wrapper/factory -->
  <script src="./stockfish.js" defer></script>
</head>
<body>
  <h2>Spicy Chess — Mild / Medium / Chaotic</h2>
  <div id="statusBar">
    <span id="phaseBadge" class="badge">Phase: Opening</span>
    <span id="sideBadge" class="badge">You: White</span>
    <span id="engineBadge" class="badge">Local AI • Intermediate</span>
    <span class="status-sep">|</span>
    <span id="stateBadge" class="badge">State: White to move</span>
  </div>

  <div id="appLayout">
    <!-- Framed board with outside coordinates -->
    <div class="board-frame">
      <div id="boardWrap">
        <div id="rankLabels"></div>
        <div id="board"></div>
        <div id="corner"></div>
        <div id="fileLabels"></div>
      </div>
      <div id="demoOverlay" aria-live="polite">
        <div id="demoOverlayCard">
          <h4 id="demoOverlayTitle">Special Move Demo</h4>
          <p id="demoOverlayBody"></p>
          <p id="demoOverlayMove"></p>
          <p id="demoOverlayQuestion">Show this move?</p>
          <div id="demoOverlayActions">
            <button id="demoYesBtn" class="primary-btn" type="button">Yes</button>
            <button id="demoNoBtn" type="button">No</button>
          </div>
        </div>
      </div>
      <div id="endgameOverlay" aria-live="polite">
        <div id="endgameOverlayCard">
          <h4 id="endgameOverlayTitle">Game Finished</h4>
          <p id="endgameOverlayBody"></p>
        </div>
      </div>
      <div class="board-actions">
        <div class="board-action-row">
          <button id="startBtn" class="primary-btn">Start Game</button>
          <button id="resignBtn" title="Resign the current game">Resign</button>
        </div>
        <button id="askHelpBtn" style="display:none;" title="Ask for your best next move">Ask Best Move</button>
        <div id="touchHint">Touch controls: tap a piece, then tap its destination square.</div>
        <div id="eloBoardPanel">
          <div><strong>White Game Rating:</strong> <span id="eloWhite">--</span></div>
          <div><strong>Black Game Rating:</strong> <span id="eloBlack">--</span></div>
          <div id="eloSummary">Game Rating appears after post-game analysis.</div>
        </div>
      </div>
    </div>

    <div id="controls">
      <div class="panel">
        <h3>Game Setup</h3>
        <div class="control-grid">
          <div class="control-item">
            <label for="modeSelect">Mode</label>
            <select id="modeSelect">
              <option value="classic">Classic</option>
              <option value="mild">Mild</option>
              <option value="medium">Medium</option>
              <option value="chaotic">Chaotic</option>
            </select>
          </div>
          <div class="control-item">
            <label for="gameTypeSelect">Game Type</label>
            <select id="gameTypeSelect" title="Choose player-vs-AI or AI-vs-AI autoplay">
              <option value="human_vs_ai" selected>Human vs AI</option>
              <option value="ai_vs_ai">AI vs AI</option>
            </select>
          </div>
          <div class="control-item">
            <label for="sideSelect">Side</label>
            <select id="sideSelect" title="Choose your side (board perspective)">
              <option value="white">White</option>
              <option value="black">Black</option>
            </select>
          </div>
          <div class="control-item">
            <label for="aiWhiteEngineSelect">AI White</label>
            <select id="aiWhiteEngineSelect" title="Engine for White in AI vs AI">
              <option value="local" selected>Local AI</option>
              <option value="stockfish">Stockfish</option>
            </select>
          </div>
          <div class="control-item">
            <label for="aiBlackEngineSelect">AI Black</label>
            <select id="aiBlackEngineSelect" title="Engine for Black in AI vs AI">
              <option value="local" selected>Local AI</option>
              <option value="stockfish">Stockfish</option>
            </select>
          </div>
          <div class="control-item">
            <label for="aiVsAiSpeedSelect">AI vs AI Speed</label>
            <select id="aiVsAiSpeedSelect" title="Delay between AI moves">
              <option value="100">Very Fast</option>
              <option value="250">Fast</option>
              <option value="500" selected>Normal</option>
              <option value="900">Slow</option>
            </select>
          </div>
          <div class="control-item">
            <label for="opponentSelect">Opponent</label>
            <select id="opponentSelect" title="Who plays the other side?">
              <option value="local">Local AI</option>
              <option value="stockfish">Stockfish (single-thread)</option>
            </select>
          </div>
          <div class="control-item">
            <label for="levelSelect">Level</label>
            <select id="levelSelect" title="Computer strength">
              <option value="beginner">Beginner</option>
              <option value="intermediate" selected>Intermediate</option>
              <option value="expert">Expert</option>
              <option value="master">Master</option>
            </select>
          </div>
          <div class="control-item">
            <label for="helpSelect">Ask for help</label>
            <select id="helpSelect" title="Show recommended next move for your side">
              <option value="off" selected>Off</option>
              <option value="on">On</option>
            </select>
          </div>
          <div class="control-item">
            <label for="timeControlSelect">Time Control</label>
            <select id="timeControlSelect" title="Per-side game clock">
              <option value="blitz">Blitz (5+0)</option>
              <option value="rapid" selected>Rapid (10+0)</option>
              <option value="classical">Classical (Unlimited)</option>
            </select>
          </div>
          <div class="control-item">
            <label for="assetCheckResult">Asset Check</label>
            <div id="assetCheckResult">Checking...</div>
          </div>
        </div>
        <div class="action-row">
          <button id="resetBtn">Reset</button>
          <button id="undoBtn" title="Undo the last full move">Undo Full Move</button>
          <button id="rematchBtn" title="Start a new game with colors swapped">Rematch (Swap Sides)</button>
          <button id="demoBtn" title="Run a scripted showcase of special moves">Run Special Moves Demo</button>
        </div>
        <div class="note" id="opponentHint">Opponent: Local greedy AI. Choose “Stockfish (single-thread)” for engine play.</div>
        <div class="note">Select a mode, then Start Game. Special buttons appear based on the mode.</div>
      </div>

      <div id="specialPanel" class="panel">
        <h3>Special Moves</h3>
        <div id="specialButtons"></div>
        <div id="specialStatus" class="note"></div>
      </div>

      <div class="panel">
        <h3>Game Info</h3>
        <div id="turnInfo" class="note">White to move</div>
        <div id="helpInfo" class="note">Help: Off</div>
        <div id="capturePanel">
          <div class="capture-box">
            <div class="capture-title">White Lost</div>
            <div id="whiteLostList" class="capture-list">-</div>
          </div>
          <div class="capture-box">
            <div class="capture-title">Black Lost</div>
            <div id="blackLostList" class="capture-list">-</div>
          </div>
        </div>
        <div id="materialWrap">
          <div id="materialLabel">Material Balance: Even</div>
          <div id="materialBar"><div id="materialFill"></div></div>
        </div>
        <div id="clockPanel">
          <div id="clockWhiteBox" class="clock-box">
            <div class="clock-label">White Clock</div>
            <div id="clockWhite" class="clock-time">10:00</div>
          </div>
          <div id="clockBlackBox" class="clock-box">
            <div class="clock-label">Black Clock</div>
            <div id="clockBlack" class="clock-time">10:00</div>
          </div>
        </div>
        <details id="moveHistoryDetails" open>
          <summary>Move History (Clickable)</summary>
          <div id="moveHistoryList"></div>
          <div id="moveHistoryActions">
            <button id="exportPgnBtn" type="button">Export PGN</button>
            <button id="replayStartBtn" type="button">Replay Start</button>
            <button id="replayPrevBtn" type="button">Prev</button>
            <button id="replayNextBtn" type="button">Next</button>
            <button id="replayPlayBtn" type="button">Play</button>
            <button id="replayPauseBtn" type="button">Pause</button>
            <button id="replayEndBtn" type="button">Replay End</button>
          </div>
        </details>
        <details id="logDetails" open>
          <summary>Move Log</summary>
          <div id="log"></div>
        </details>
      </div>
    </div>
  </div>

<script>
/* =========================
   Globals & game state
   ========================= */
let board = null;
let game = null;                 // chess.js instance
let boardConfig = null;
let modeConfig = null;
let modeName = 'mild';
let userSide = 'white'; // 'white' or 'black' — used for board orientation
let gameType = 'human_vs_ai';   // human_vs_ai | ai_vs_ai
let aiVsAiEngines = { w: 'local', b: 'local' };
let aiVsAiMoveDelayMs = 500;
let aiVsAiTimer = null;

// Opponents
let opponentType = 'local';      // 'local' | 'stockfish'
let aiLevel = 'intermediate';    // beginner | intermediate | expert | master
let helpMode = 'off';            // off | on
let sfWorker = null;
let sfReady = false;
let sfWantGo = false;            // when true, send position+go on next readyok
let sfLastGoFen = '';            // FEN that current Stockfish search was started from
let sfLastGoTs = 0;
let sfBestmoveTimer = null;
let sfInitInProgress = false;
let sfInitStartedTs = 0;
let sfDisabled = false;
let aiServerUrl = '';            // (unused here—kept for compatibility)

let moveHistory = [];            // list of FENs (for Back in Time)
let moveSans = [];               // SAN/custom text per ply for history panel
let specialStateHistory = [];    // snapshots aligned to moveHistory indexes
let lostPiecesHistory = [];      // snapshots aligned to moveHistory indexes
let halfMoveCount = 0;           // ply counter (for random events)
let randomEventInterval = 8;     // chaotic mode trigger interval
let isDemoRunning = false;       // suppresses AI auto-moves during scripted demo
let lastMoveSquares = { from: null, to: null };
let legalTargetSquares = [];
let demoDecisionResolver = null;
let demoDragState = { active: false, dx: 0, dy: 0 };
let gameResultHandled = false;
let gameStatusOverride = null;   // { text, kind }
let gameRatings = {
  w: { rating: null, accuracy: null, avgCpl: null, moves: 0 },
  b: { rating: null, accuracy: null, avgCpl: null, moves: 0 }
};
let gameSessionId = 0;
let gameActive = false;
let timeControl = 'rapid';       // blitz | rapid | classical
const timeControlSeconds = { blitz: 300, rapid: 600, classical: Infinity };
let clockSeconds = { w: 600, b: 600 };
let clockTicker = null;
let lastClockTs = 0;
let touchMoveSource = null;
let boardTouchInputBound = null;
const squareHandlerBindings = new Map();
let helpPreviewMove = { from: null, to: null };
let helpPreviewTimer = null;
let demoDialogArmedAt = 0;
let boardReadySessionId = 0;
let hintSearchInProgress = false;
let searchDeadlineAt = 0;
let searchAbortFlag = false;
let searchTT = new Map();
const SEARCH_TT_MAX = 100000;
let replayModeActive = false;
let replayPly = 0;
let replayTimer = null;
const inputCapabilities = (() => {
  if (typeof window === 'undefined') {
    return { hasCoarse: false, hasFine: false, hasTouch: false };
  }

  const hasCoarse = !!window.matchMedia && window.matchMedia('(any-pointer: coarse)').matches;
  const hasFine = !!window.matchMedia && window.matchMedia('(any-pointer: fine)').matches;
  const hasTouch = ('ontouchstart' in window) || ((typeof navigator !== 'undefined' && Number(navigator.maxTouchPoints) > 0));

  return { hasCoarse, hasFine, hasTouch };
})();

const prefersTapInput =
  (inputCapabilities.hasCoarse && !inputCapabilities.hasFine) ||
  (inputCapabilities.hasTouch && !inputCapabilities.hasFine && !inputCapabilities.hasCoarse);

const openingBookLines = [
  ['e2e4', 'e7e5', 'g1f3', 'b8c6', 'f1b5'],
  ['e2e4', 'e7e5', 'g1f3', 'b8c6', 'f1c4'],
  ['e2e4', 'c7c5', 'g1f3', 'd7d6', 'd2d4'],
  ['d2d4', 'd7d5', 'c2c4', 'e7e6', 'b1c3'],
  ['d2d4', 'g8f6', 'c2c4', 'e7e6', 'g1f3'],
  ['c2c4', 'e7e5', 'b1c3', 'g8f6', 'g2g3'],
  ['g1f3', 'd7d5', 'd2d4', 'g8f6', 'c2c4']
];

let playerSpecialState = {
  w: { swapUsed:false, shadowCooldown:0, backInTimeUsed:false, resurrectionUsed:false },
  b: { swapUsed:false, shadowCooldown:0, backInTimeUsed:false, resurrectionUsed:false },
};

// track captured pieces per side (lowercase types q,r,b,n,p) for Resurrection
let lostPieces = { w: [], b: [] };

// not used right now, kept for future features:
let fusionTemp = null;
let doubleMoveUsedBy = {};

/* Mode capabilities */
const gameModes = {
  classic: {
    swapMove: false,
    pawnPromotionAnywhere: false,
    shadowStep: false,
    doubleTake: false,
    resurrection: false,
    pieceFusion: false,
    backInTime: false,
    randomEvents: false
  },
  mild: {
    swapMove: true,
    pawnPromotionAnywhere: true,
    shadowStep: false,
    doubleTake: false,
    resurrection: false,
    pieceFusion: false,
    backInTime: false,
    randomEvents: false
  },
  medium: {
    swapMove: false,
    pawnPromotionAnywhere: false,
    shadowStep: true,     // knight “blink” with cooldown
    doubleTake: false,    // disabled for now (to keep stable)
    resurrection: true,   // once per game
    pieceFusion: false,   // disabled until fully implemented
    backInTime: false,
    randomEvents: false
  },
  chaotic: {
    swapMove: false,
    pawnPromotionAnywhere: false,
    shadowStep: false,
    doubleTake: false,
    resurrection: false,
    pieceFusion: false,   // disabled until fully implemented
    backInTime: true,     // once per game
    randomEvents: true
  }
};

const aiLevels = {
  beginner: {
    label: 'Beginner',
    stockfish: { skill: 3, movetimeMs: 350, depth: 8, elo: 900 },
    local: { depth: 1, blunderRate: 0.50, randomness: 2.2 }
  },
  intermediate: {
    label: 'Intermediate',
    stockfish: { skill: 8, movetimeMs: 900, depth: 12, elo: 1400 },
    local: { depth: 2, blunderRate: 0.15, randomness: 0.7 }
  },
  expert: {
    label: 'Expert',
    stockfish: { skill: 14, movetimeMs: 1600, depth: 16, elo: 1900 },
    local: { depth: 2, blunderRate: 0.03, randomness: 0.15 }
  },
  master: {
    label: 'Master',
    stockfish: { skill: 20, movetimeMs: 2600, depth: 22, elo: 2400 },
    local: { depth: 3, blunderRate: 0.0, randomness: 0.01 }
  }
};

function getAiLevelConfig() {
  return aiLevels[aiLevel] || aiLevels.intermediate;
}

function getHelpDepthByLevel() {
  const cfg = getAiLevelConfig().local;
  const base = Math.max(1, cfg.depth | 0);
  return Math.min(4, base + 1);
}

function getHelpTimeBudgetByLevel() {
  const lvl = String(aiLevel || 'intermediate');
  if (lvl === 'beginner') return 450;
  if (lvl === 'expert') return 1000;
  if (lvl === 'master') return 1400;
  return 750; // intermediate default
}

function getLocalAiTimeBudgetByLevel() {
  const lvl = String(aiLevel || 'intermediate');
  if (lvl === 'beginner') return 180;
  if (lvl === 'expert') return 650;
  if (lvl === 'master') return 1150;
  return 350; // intermediate default
}

function pickBestMoveDeterministic(depth) {
  const legal = game.moves({ verbose: true });
  if (!legal.length) return null;
  let best = null;
  let bestScore = -Infinity;
  for (const m of legal) {
    game.move(m);
    const score = -negamax(Math.max(0, depth - 1), -Infinity, Infinity);
    game.undo();
    if (score > bestScore) {
      bestScore = score;
      best = m;
    }
  }
  return { move: best, score: bestScore };
}

function searchTimedOut() {
  return searchDeadlineAt > 0 && performance.now() >= searchDeadlineAt;
}

function resetSearchContext(budgetMs = 0, useTT = true) {
  searchAbortFlag = false;
  searchDeadlineAt = budgetMs > 0 ? (performance.now() + Math.max(80, budgetMs | 0)) : 0;
  if (!useTT) searchTT.clear();
}

function endSearchContext() {
  searchAbortFlag = false;
  searchDeadlineAt = 0;
}

function ttGet(fen) {
  return searchTT.get(fen) || null;
}

function ttSet(fen, entry) {
  if (!fen || !entry) return;
  if (searchTT.size >= SEARCH_TT_MAX) searchTT.clear();
  searchTT.set(fen, entry);
}

async function pickBestMoveDeterministicTimed(maxDepth, budgetMs) {
  const legal = game.moves({ verbose: true });
  if (!legal.length) return null;
  const bookMove = pickOpeningBookMove();
  if (bookMove) return { move: bookMove, score: 0, depth: 0, timedOut: false, fromBook: true };

  let rootMoves = orderedMoves(legal);
  let bestOverall = null;
  let bestCompleted = null;
  const tEnd = performance.now() + Math.max(250, budgetMs | 0);

  for (let depth = 1; depth <= Math.max(1, maxDepth | 0); depth++) {
    if (performance.now() >= tEnd) break;
    if (bestCompleted && bestCompleted.move) {
      const key = bestCompleted.move.from + bestCompleted.move.to + (bestCompleted.move.promotion || '');
      rootMoves = rootMoves.slice().sort((a, b) => {
        const ka = a.from + a.to + (a.promotion || '');
        const kb = b.from + b.to + (b.promotion || '');
        if (ka === key) return -1;
        if (kb === key) return 1;
        return 0;
      });
    }

    searchAbortFlag = false;
    searchDeadlineAt = tEnd;
    let best = null;
    let bestScore = -Infinity;
    for (const m of rootMoves) {
      if (searchTimedOut()) { searchAbortFlag = true; break; }
      game.move(m);
      const score = -negamax(depth - 1, -Infinity, Infinity);
      game.undo();
      if (score > bestScore) {
        bestScore = score;
        best = m;
      }
    }

    if (best) bestOverall = { move: best, score: bestScore, depth, timedOut: searchAbortFlag };
    if (best && !searchAbortFlag) bestCompleted = { move: best, score: bestScore, depth, timedOut: false };
    if (searchAbortFlag) break;

    // Yield between depth iterations so UI can update.
    await new Promise(resolve => setTimeout(resolve, 0));
  }

  endSearchContext();
  return bestCompleted || bestOverall || { move: rootMoves[0], score: 0, depth: 1, timedOut: true };
}

function updateHelpButtonState() {
  const btn = document.getElementById('askHelpBtn');
  if (!btn) return;
  const on = helpMode === 'on';
  btn.style.display = on ? 'inline-block' : 'none';
  if (!on) { btn.disabled = true; return; }
  const canAsk = !!(game && !game.game_over() && game.turn() === getUserColorCode() && !isDemoRunning && !hintSearchInProgress && !isAiVsAiActive());
  btn.disabled = !canAsk;
}

function updateResignButtonState() {
  const btn = document.getElementById('resignBtn');
  if (!btn) return;
  const canResign = !!(game && gameActive && !gameResultHandled && !isDemoRunning && !isAiVsAiActive());
  btn.disabled = !canResign;
}

function updateHelpInfo() {
  const el = document.getElementById('helpInfo');
  if (!el) return;
  if (helpMode !== 'on') {
    clearHelpPreview();
    el.textContent = 'Help: Off';
    updateHelpButtonState();
    return;
  }
  if (!game) {
    clearHelpPreview();
    el.textContent = 'Help: On. Start a game, then click Ask Best Move.';
    updateHelpButtonState();
    return;
  }
  if (game.game_over()) {
    clearHelpPreview();
    el.textContent = 'Help: Game over.';
    updateHelpButtonState();
    return;
  }
  const myColor = getUserColorCode();
  if (game.turn() !== myColor) {
    clearHelpPreview();
    el.textContent = 'Help: Wait for your turn, then click Ask Best Move.';
    updateHelpButtonState();
    return;
  }
  el.textContent = 'Help: Ready. Click Ask Best Move.';
  updateHelpButtonState();
}

async function onAskHelpClick() {
  if (helpMode !== 'on') return;
  if (isAiVsAiActive()) return;
  const el = document.getElementById('helpInfo');
  if (!el) return;
  if (hintSearchInProgress) return;
  if (!game) { el.textContent = 'Help: Start a game first.'; updateHelpButtonState(); return; }
  if (game.game_over()) { el.textContent = 'Help: Game over.'; updateHelpButtonState(); return; }
  if (game.turn() !== getUserColorCode()) { el.textContent = 'Help: It is not your turn yet.'; updateHelpButtonState(); return; }
  hintSearchInProgress = true;
  updateHelpButtonState();
  el.textContent = 'Help: Calculating best move...';
  await new Promise(resolve => setTimeout(resolve, 0));
  try {
    const depth = getHelpDepthByLevel();
    const budgetMs = getHelpTimeBudgetByLevel();
    const best = await pickBestMoveDeterministicTimed(depth, budgetMs);
    if (!best || !best.move) {
      el.textContent = 'Help: No legal move found.';
      clearHelpPreview();
      return;
    }
    const mv = best.move;
    const sanText = escapeHtml(mv.san || '?');
    const fromText = escapeHtml(mv.from || '--');
    const toText = escapeHtml(mv.to || '--');
    let suffix = '';
    if (best.fromBook) suffix = ' (opening book)';
    else if (best.timedOut) suffix = ' (time-limited search)';
    el.innerHTML = `Help: Best move is <strong>${sanText}</strong> (<span class="hint-from-text">${fromText}</span> to <span class="hint-to-text">${toText}</span>)${suffix}.`;
    showHelpPreview(mv.from, mv.to, 3000);
  } finally {
    hintSearchInProgress = false;
    updateHelpButtonState();
  }
}

function onResignClick() {
  if (!game || !gameActive || gameResultHandled || isDemoRunning) return;
  const resigningColor = getUserColorCode();
  const winnerColor = resigningColor === 'w' ? 'b' : 'w';
  const winnerName = winnerColor === 'w' ? 'White' : 'Black';
  const reason = `${winnerName} wins by resignation`;
  const scoreWhite = winnerColor === 'w' ? 1 : 0;

  gameStatusOverride = {
    text: `State: ${reason}`,
    kind: 'state-win'
  };
  stopClockTicker();
  clearAiVsAiTimer();
  gameActive = false;
  gameResultHandled = true;
  updateResignButtonState();
  log(reason + '.');
  const sessionAtEnd = gameSessionId;
  finalizeGameRatings(reason, scoreWhite, sessionAtEnd).catch((err) => {
    console.error('Game rating analysis failed:', err);
    if (sessionAtEnd !== gameSessionId) return;
    gameRatings = buildFallbackGameRatings(scoreWhite);
    const summary = `${reason}. ${formatSideGameRatingLine('w')}. ${formatSideGameRatingLine('b')}.`;
    updateEloBoardPanel(summary);
    showEndgameOverlay('Game Finished', summary);
  });
  updateTurnInfo();
}

function updateOpponentHint() {
  const hint = document.getElementById('opponentHint');
  if (!hint) { updateStatusBar(); return; }
  const lvl = getAiLevelConfig().label;
  if (gameType === 'ai_vs_ai') {
    hint.textContent = `AI vs AI: White=${aiVsAiEngines.w === 'stockfish' ? 'Stockfish' : 'Local AI'}, Black=${aiVsAiEngines.b === 'stockfish' ? 'Stockfish' : 'Local AI'} • Level: ${lvl}.`;
  } else if (opponentType === 'stockfish') {
    hint.textContent = `Opponent: Stockfish (single-thread) • Level: ${lvl}.`;
  } else {
    hint.textContent = `Opponent: Local AI • Level: ${lvl}.`;
  }
  updateStatusBar();
}

function isAiVsAiActive() {
  return gameType === 'ai_vs_ai';
}

function aiVsAiNeedsStockfish() {
  return isAiVsAiActive() && (aiVsAiEngines.w === 'stockfish' || aiVsAiEngines.b === 'stockfish');
}

function clearAiVsAiTimer() {
  if (aiVsAiTimer) {
    clearTimeout(aiVsAiTimer);
    aiVsAiTimer = null;
  }
}

function clearReplayTimer() {
  if (replayTimer) {
    clearInterval(replayTimer);
    replayTimer = null;
  }
}

function updateGameTypeUI() {
  const isA = isAiVsAiActive();
  const sideWrap = document.getElementById('sideSelect')?.closest('.control-item');
  const oppWrap = document.getElementById('opponentSelect')?.closest('.control-item');
  const whiteWrap = document.getElementById('aiWhiteEngineSelect')?.closest('.control-item');
  const blackWrap = document.getElementById('aiBlackEngineSelect')?.closest('.control-item');
  const speedWrap = document.getElementById('aiVsAiSpeedSelect')?.closest('.control-item');
  if (sideWrap) sideWrap.style.display = isA ? 'none' : '';
  if (oppWrap) oppWrap.style.display = isA ? 'none' : '';
  if (whiteWrap) whiteWrap.style.display = isA ? '' : 'none';
  if (blackWrap) blackWrap.style.display = isA ? '' : 'none';
  if (speedWrap) speedWrap.style.display = isA ? '' : 'none';
}

/* =========================
   UI wiring
   ========================= */
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('resetBtn').addEventListener('click', () => location.reload());
document.getElementById('demoBtn').addEventListener('click', runSpecialMovesDemo);
document.getElementById('undoBtn').addEventListener('click', onUndoFullMoveClick);
document.getElementById('rematchBtn').addEventListener('click', onRematchSwapSidesClick);
const exportPgnBtn = document.getElementById('exportPgnBtn');
if (exportPgnBtn) exportPgnBtn.addEventListener('click', exportPgnText);
const oppSel = document.getElementById('opponentSelect');
const gameTypeSel = document.getElementById('gameTypeSelect');
const aiWhiteSel = document.getElementById('aiWhiteEngineSelect');
const aiBlackSel = document.getElementById('aiBlackEngineSelect');
const aiVsAiSpeedSel = document.getElementById('aiVsAiSpeedSelect');
const levelSel = document.getElementById('levelSelect');
const helpSel = document.getElementById('helpSelect');
const sideSel = document.getElementById('sideSelect');
const modeSel = document.getElementById('modeSelect');
const tcSel = document.getElementById('timeControlSelect');
const askHelpBtn = document.getElementById('askHelpBtn');
const resignBtn = document.getElementById('resignBtn');
const demoYesBtn = document.getElementById('demoYesBtn');
const demoNoBtn = document.getElementById('demoNoBtn');
const replayStartBtn = document.getElementById('replayStartBtn');
const replayPrevBtn = document.getElementById('replayPrevBtn');
const replayNextBtn = document.getElementById('replayNextBtn');
const replayPlayBtn = document.getElementById('replayPlayBtn');
const replayPauseBtn = document.getElementById('replayPauseBtn');
const replayEndBtn = document.getElementById('replayEndBtn');
if (oppSel) {
  oppSel.addEventListener('change', () => {
    opponentType = oppSel.value;
    updateOpponentHint();
  });
}
if (gameTypeSel) {
  gameTypeSel.addEventListener('change', () => {
    gameType = gameTypeSel.value || 'human_vs_ai';
    updateGameTypeUI();
    updateOpponentHint();
    updateTurnInfo();
  });
}
if (aiWhiteSel) {
  aiWhiteSel.addEventListener('change', () => {
    aiVsAiEngines.w = aiWhiteSel.value || 'local';
    updateOpponentHint();
    updateTurnInfo();
  });
}
if (aiBlackSel) {
  aiBlackSel.addEventListener('change', () => {
    aiVsAiEngines.b = aiBlackSel.value || 'local';
    updateOpponentHint();
    updateTurnInfo();
  });
}
if (aiVsAiSpeedSel) {
  aiVsAiSpeedSel.addEventListener('change', () => {
    aiVsAiMoveDelayMs = parseInt(aiVsAiSpeedSel.value || '500', 10) || 500;
  });
}
if (levelSel) {
  levelSel.addEventListener('change', () => {
    aiLevel = levelSel.value;
    updateOpponentHint();
    updateHelpInfo();
  });
}
if (helpSel) {
  helpSel.addEventListener('change', () => {
    helpMode = helpSel.value;
    updateHelpInfo();
  });
}
if (sideSel) {
  sideSel.addEventListener('change', () => {
    userSide = sideSel.value;
    setupBoardLabels();
    if (board) board.orientation(userSide === 'black' ? 'black' : 'white');
    updateStatusBar();
  });
}
if (modeSel) {
  modeSel.addEventListener('change', () => {
    modeName = modeSel.value;
    updateStatusBar();
  });
}
if (tcSel) {
  tcSel.addEventListener('change', () => {
    timeControl = tcSel.value || 'rapid';
    initializeClocks();
    updateStatusBar();
  });
}
if (askHelpBtn) {
  askHelpBtn.addEventListener('click', onAskHelpClick);
}
if (resignBtn) {
  resignBtn.addEventListener('click', onResignClick);
}
if (replayStartBtn) replayStartBtn.addEventListener('click', () => replayJumpTo(0));
if (replayPrevBtn) replayPrevBtn.addEventListener('click', () => replayStep(-1));
if (replayNextBtn) replayNextBtn.addEventListener('click', () => replayStep(1));
if (replayPlayBtn) replayPlayBtn.addEventListener('click', startReplayAutoPlay);
if (replayPauseBtn) replayPauseBtn.addEventListener('click', pauseReplayAutoPlay);
if (replayEndBtn) replayEndBtn.addEventListener('click', () => replayJumpTo(Math.max(0, moveHistory.length - 1)));
if (demoYesBtn) {
  demoYesBtn.addEventListener('click', () => {
    if (Date.now() < demoDialogArmedAt) return;
    if (demoDecisionResolver) {
      const cb = demoDecisionResolver;
      demoDecisionResolver = null;
      cb(true);
    }
  });
}
if (demoNoBtn) {
  demoNoBtn.addEventListener('click', () => {
    if (Date.now() < demoDialogArmedAt) return;
    if (demoDecisionResolver) {
      const cb = demoDecisionResolver;
      demoDecisionResolver = null;
      cb(false);
    }
  });
}
const logDetails = document.getElementById('logDetails');
if (logDetails && window.matchMedia && window.matchMedia('(max-width: 980px)').matches) {
  logDetails.open = false;
}

function formatClock(sec) {
  if (!isFinite(sec)) return '∞';
  const s = Math.max(0, Math.ceil(sec));
  const mm = Math.floor(s / 60);
  const ss = s % 60;
  return `${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
}

function updateClockUI(activeColor = null) {
  const w = document.getElementById('clockWhite');
  const b = document.getElementById('clockBlack');
  const wb = document.getElementById('clockWhiteBox');
  const bb = document.getElementById('clockBlackBox');
  if (w) w.textContent = formatClock(clockSeconds.w);
  if (b) b.textContent = formatClock(clockSeconds.b);
  if (wb) wb.classList.toggle('active', activeColor === 'w');
  if (bb) bb.classList.toggle('active', activeColor === 'b');
}

function stopClockTicker() {
  if (clockTicker) {
    clearInterval(clockTicker);
    clockTicker = null;
  }
}

function initializeClocks() {
  const base = timeControlSeconds[timeControl] || timeControlSeconds.rapid;
  clockSeconds = { w: base, b: base };
  stopClockTicker();
  updateClockUI(null);
}

function onTimeExpired(colorFlagged) {
  if (!game || gameResultHandled) return;
  const winnerColor = (colorFlagged === 'w') ? 'b' : 'w';
  const reason = `${winnerColor === 'w' ? 'White' : 'Black'} wins on time`;
  gameStatusOverride = { text: `State: ${winnerColor === 'w' ? 'White' : 'Black'} won on time`, kind: 'state-win' };
  stopClockTicker();
  clearAiVsAiTimer();
  gameActive = false;
  gameResultHandled = true;
  updateResignButtonState();
  log(reason + '.');
  const scoreWhite = (winnerColor === 'w') ? 1 : 0;
  finalizeGameRatings(reason, scoreWhite, gameSessionId).catch((err) => {
    console.error('Game rating analysis failed:', err);
  });
  updateTurnInfo();
}

function startClockFor(color) {
  if (!gameActive || !game || game.game_over() || isDemoRunning || gameResultHandled) {
    stopClockTicker();
    updateClockUI(null);
    return;
  }
  const active = (color === 'b') ? 'b' : 'w';
  stopClockTicker();
  if (!isFinite(clockSeconds[active])) {
    updateClockUI(active);
    return;
  }
  lastClockTs = Date.now();
  updateClockUI(active);
  clockTicker = setInterval(() => {
    const now = Date.now();
    const dt = (now - lastClockTs) / 1000;
    lastClockTs = now;
    clockSeconds[active] = Math.max(0, clockSeconds[active] - dt);
    updateClockUI(active);
    if (clockSeconds[active] <= 0) {
      onTimeExpired(active);
    }
  }, 200);
}

function recordMoveText(text) {
  moveSans.push(text || '?');
  renderMoveHistoryPanel();
}

function updateLastMoveText(text) {
  if (!moveSans.length) return;
  moveSans[moveSans.length - 1] = text || moveSans[moveSans.length - 1];
  renderMoveHistoryPanel();
}

function cloneSpecialState() {
  return {
    w: { ...playerSpecialState.w },
    b: { ...playerSpecialState.b }
  };
}

function cloneLostPieces() {
  return {
    w: lostPieces.w.slice(),
    b: lostPieces.b.slice()
  };
}

function pushStateSnapshot() {
  specialStateHistory.push(cloneSpecialState());
  lostPiecesHistory.push(cloneLostPieces());
}

function restoreStateSnapshotAt(index) {
  const i = Math.max(0, Math.min(index, specialStateHistory.length - 1));
  if (!specialStateHistory[i] || !lostPiecesHistory[i]) return;
  playerSpecialState = {
    w: { ...specialStateHistory[i].w },
    b: { ...specialStateHistory[i].b }
  };
  lostPieces = {
    w: lostPiecesHistory[i].w.slice(),
    b: lostPiecesHistory[i].b.slice()
  };
}

function appendHistoryEntry(moveText) {
  moveHistory.push(game.fen());
  recordMoveText(moveText);
  pushStateSnapshot();
}

function trimHistoryToPly(ply) {
  clearReplayTimer();
  replayModeActive = false;
  moveHistory = moveHistory.slice(0, ply + 1);
  moveSans = moveSans.slice(0, ply);
  specialStateHistory = specialStateHistory.slice(0, ply + 1);
  lostPiecesHistory = lostPiecesHistory.slice(0, ply + 1);
  restoreStateSnapshotAt(ply);
  halfMoveCount = ply;
  gameResultHandled = false;
  gameStatusOverride = null;
  gameActive = true;
  hideEndgameOverlay();
  setLastMove(null, null);
  renderMoveHistoryPanel();
  updateReplayControlsState();
}

function renderMoveHistoryPanel() {
  const list = document.getElementById('moveHistoryList');
  if (!list) return;
  list.innerHTML = '';
  if (!moveSans.length) {
    list.textContent = 'No moves yet.';
    updateReplayControlsState();
    return;
  }
  for (let i = 0; i < moveSans.length; i += 2) {
    const row = document.createElement('div');
    row.className = 'move-row';
    const num = document.createElement('div');
    num.className = 'move-num';
    num.textContent = String(Math.floor(i / 2) + 1) + '.';
    row.appendChild(num);

    const wBtn = document.createElement('button');
    wBtn.type = 'button';
    wBtn.className = 'move-btn';
    wBtn.textContent = moveSans[i];
    wBtn.addEventListener('click', () => jumpToPly(i + 1));
    row.appendChild(wBtn);

    const bBtn = document.createElement('button');
    bBtn.type = 'button';
    bBtn.className = 'move-btn';
    if (typeof moveSans[i + 1] === 'string') {
      bBtn.textContent = moveSans[i + 1];
      bBtn.addEventListener('click', () => jumpToPly(i + 2));
    } else {
      bBtn.textContent = '';
      bBtn.disabled = true;
    }
    row.appendChild(bBtn);
    list.appendChild(row);
  }
  updateReplayControlsState();
}

function jumpToPly(ply) {
  if (!game || ply < 0 || ply >= moveHistory.length) return;
  if (!confirm(`Jump to move ${ply}? This trims later moves.`)) return;
  const fen = moveHistory[ply];
  if (!game.load(fen)) return;
  board.position(game.fen());
  trimHistoryToPly(ply);
  updateTurnInfo();
  refreshSpecialButtons();
  startClockFor(game.turn());
  log(`Jumped to ply ${ply}.`);
}

function updateReplayControlsState() {
  const hasData = !!(game && moveHistory.length > 1);
  const atStart = replayPly <= 0;
  const atEnd = replayPly >= Math.max(0, moveHistory.length - 1);
  if (replayStartBtn) replayStartBtn.disabled = !hasData || atStart;
  if (replayPrevBtn) replayPrevBtn.disabled = !hasData || atStart;
  if (replayNextBtn) replayNextBtn.disabled = !hasData || atEnd;
  if (replayEndBtn) replayEndBtn.disabled = !hasData || atEnd;
  if (replayPlayBtn) replayPlayBtn.disabled = !hasData || atEnd || !!replayTimer;
  if (replayPauseBtn) replayPauseBtn.disabled = !replayTimer;
}

function replayJumpTo(targetPly) {
  if (!game || !board || !moveHistory.length) return;
  clearReplayTimer();
  replayModeActive = true;
  const maxPly = Math.max(0, moveHistory.length - 1);
  replayPly = Math.max(0, Math.min(maxPly, targetPly | 0));
  const fen = moveHistory[replayPly];
  if (!fen || !game.load(fen)) return;
  board.position(game.fen());
  setLastMove(null, null);
  updateTurnInfo();
  refreshSpecialButtons();
  stopClockTicker();
  updateClockUI(null);
  updateReplayControlsState();
}

function replayStep(delta) {
  if (!moveHistory.length) return;
  if (!replayModeActive) replayPly = Math.max(0, moveHistory.length - 1);
  replayJumpTo(replayPly + delta);
}

function pauseReplayAutoPlay() {
  clearReplayTimer();
  updateReplayControlsState();
}

function startReplayAutoPlay() {
  if (!game || !moveHistory.length) return;
  if (!replayModeActive) replayJumpTo(0);
  clearReplayTimer();
  replayTimer = setInterval(() => {
    if (replayPly >= Math.max(0, moveHistory.length - 1)) {
      clearReplayTimer();
      updateReplayControlsState();
      return;
    }
    replayJumpTo(replayPly + 1);
  }, Math.max(120, aiVsAiMoveDelayMs));
  updateReplayControlsState();
}

function buildFallbackMoveText() {
  const out = [];
  for (let i = 0; i < moveSans.length; i += 2) {
    let line = `${Math.floor(i / 2) + 1}. ${moveSans[i] || ''}`;
    if (moveSans[i + 1]) line += ` ${moveSans[i + 1]}`;
    out.push(line);
  }
  return out.join(' ');
}

function exportPgnText() {
  let payload = '';
  try { payload = game ? game.pgn() : ''; } catch (_) {}
  if (!payload || !payload.trim()) payload = buildFallbackMoveText();
  if (!payload) payload = '(no moves)';
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(payload).then(() => log('PGN copied to clipboard.')).catch(() => prompt('Copy PGN:', payload));
  } else {
    prompt('Copy PGN:', payload);
  }
}

function onUndoFullMoveClick() {
  if (!game || moveHistory.length < 2) return alert('No moves to undo.');
  const remove = Math.min(2, moveHistory.length - 1);
  const targetPly = moveHistory.length - 1 - remove;
  const fen = moveHistory[targetPly];
  if (!fen || !game.load(fen)) return alert('Could not undo.');
  board.position(game.fen());
  trimHistoryToPly(targetPly);
  updateTurnInfo();
  refreshSpecialButtons();
  startClockFor(game.turn());
  log('Undid last full move.');
}

function onRematchSwapSidesClick() {
  const side = document.getElementById('sideSelect');
  if (side) side.value = (userSide === 'white') ? 'black' : 'white';
  startGame();
}

function log(msg) {
  const el = document.getElementById('log');
  el.innerHTML = (new Date()).toLocaleTimeString() + ' — ' + msg + '<br/>' + el.innerHTML;
}

function getPhaseLabel() {
  if (!game) return 'Opening';
  const ply = halfMoveCount;
  let nonPawnMaterial = 0;
  const b = game.board();
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (!p || p.type === 'p' || p.type === 'k') continue;
    nonPawnMaterial += 1;
  }
  if (ply < 16) return 'Opening';
  if (nonPawnMaterial <= 6) return 'Endgame';
  return 'Middlegame';
}

function updateStatusBar() {
  const phase = document.getElementById('phaseBadge');
  const side = document.getElementById('sideBadge');
  const engine = document.getElementById('engineBadge');
  const state = document.getElementById('stateBadge');
  if (!phase || !side || !engine || !state) return;

  if (isAiVsAiActive()) side.textContent = 'You: Spectator';
  else side.textContent = `You: ${userSide === 'black' ? 'Black' : 'White'}`;
  if (isAiVsAiActive()) {
    const w = aiVsAiEngines.w === 'stockfish' ? 'SF' : 'Local';
    const b = aiVsAiEngines.b === 'stockfish' ? 'SF' : 'Local';
    engine.textContent = `AI vs AI (${w} vs ${b}) • ${getAiLevelConfig().label}`;
  } else {
    engine.textContent = `${opponentType === 'stockfish' ? 'Stockfish' : 'Local AI'} • ${getAiLevelConfig().label}`;
  }
  phase.textContent = `Phase: ${getPhaseLabel()}`;

  state.classList.remove('state-check', 'state-win', 'state-draw');
  if (gameStatusOverride && gameResultHandled) {
    state.textContent = gameStatusOverride.text;
    state.classList.add(gameStatusOverride.kind || 'state-win');
    return;
  }
  if (!game) { state.textContent = 'State: Ready to start'; return; }
  if (game.in_checkmate()) {
    state.textContent = `State: Checkmate (${game.turn() === 'w' ? 'Black' : 'White'} won)`;
    state.classList.add('state-win');
  } else if (game.in_stalemate() || game.in_draw() || game.in_threefold_repetition()) {
    state.textContent = 'State: Draw';
    state.classList.add('state-draw');
  } else if (game.in_check()) {
    state.textContent = `State: ${game.turn() === 'w' ? 'White' : 'Black'} in check`;
    state.classList.add('state-check');
  } else {
    state.textContent = `State: ${game.turn() === 'w' ? 'White' : 'Black'} to move`;
  }
}

function getLostPiecesByColor() {
  const startCounts = { p: 8, n: 2, b: 2, r: 2, q: 1 };
  const present = {
    w: { p: 0, n: 0, b: 0, r: 0, q: 0 },
    b: { p: 0, n: 0, b: 0, r: 0, q: 0 }
  };
  if (!game) return { w: [], b: [] };
  const b = game.board();
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (!p || p.type === 'k') continue;
    present[p.color][p.type] += 1;
  }
  const lost = { w: [], b: [] };
  for (const t of ['q', 'r', 'b', 'n', 'p']) {
    const lw = Math.max(0, startCounts[t] - present.w[t]);
    const lb = Math.max(0, startCounts[t] - present.b[t]);
    for (let i = 0; i < lw; i++) lost.w.push(t);
    for (let i = 0; i < lb; i++) lost.b.push(t);
  }
  return lost;
}

function renderPieceSymbols(types, color) {
  const map = {
    w: { q: '♕', r: '♖', b: '♗', n: '♘', p: '♙' },
    b: { q: '♛', r: '♜', b: '♝', n: '♞', p: '♟' }
  };
  if (!types.length) return '-';
  return types.map(t => map[color][t] || '?').join(' ');
}

function refreshCaptureAndMaterialUI() {
  const whiteLostEl = document.getElementById('whiteLostList');
  const blackLostEl = document.getElementById('blackLostList');
  const matLabel = document.getElementById('materialLabel');
  const matFill = document.getElementById('materialFill');
  if (!whiteLostEl || !blackLostEl || !matLabel || !matFill) return;
  if (!game) {
    whiteLostEl.textContent = '-';
    blackLostEl.textContent = '-';
    matLabel.textContent = 'Material Balance: Even';
    matFill.style.width = '50%';
    return;
  }

  const lost = getLostPiecesByColor();
  whiteLostEl.textContent = renderPieceSymbols(lost.w, 'w');
  blackLostEl.textContent = renderPieceSymbols(lost.b, 'b');

  const vals = { p: 1, n: 3, b: 3, r: 5, q: 9 };
  const score = types => types.reduce((s, t) => s + (vals[t] || 0), 0);
  const whiteDown = score(lost.w);
  const blackDown = score(lost.b);
  const whiteAdv = blackDown - whiteDown;
  const pct = Math.max(5, Math.min(95, 50 + (whiteAdv * 3)));
  matFill.style.width = `${pct}%`;
  if (whiteAdv > 0) matLabel.textContent = `Material Balance: White +${whiteAdv}`;
  else if (whiteAdv < 0) matLabel.textContent = `Material Balance: Black +${Math.abs(whiteAdv)}`;
  else matLabel.textContent = 'Material Balance: Even';
}

function clearBoardHighlightClasses() {
  const els = document.querySelectorAll('[data-square]');
  els.forEach(el => el.classList.remove('sq-last-from', 'sq-last-to', 'sq-legal', 'sq-check', 'sq-demo-from', 'sq-demo-to', 'sq-hint-from', 'sq-hint-to'));
}

function findKingSquare(colorCode) {
  if (!game) return null;
  const b = game.board();
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (p && p.color === colorCode && p.type === 'k') return String.fromCharCode(97 + f) + String(8 - r);
  }
  return null;
}

function applyBoardHighlights() {
  setTimeout(() => {
    clearBoardHighlightClasses();
    if (lastMoveSquares.from) highlightByClass(lastMoveSquares.from, 'sq-last-from');
    if (lastMoveSquares.to) highlightByClass(lastMoveSquares.to, 'sq-last-to');
    if (helpPreviewMove.from) highlightByClass(helpPreviewMove.from, 'sq-hint-from');
    if (helpPreviewMove.to) highlightByClass(helpPreviewMove.to, 'sq-hint-to');
    legalTargetSquares.forEach(sq => highlightByClass(sq, 'sq-legal'));
    if (game && game.in_check()) {
      const ksq = findKingSquare(game.turn());
      if (ksq) highlightByClass(ksq, 'sq-check');
    }
  }, 0);
}

function highlightByClass(square, klass) {
  const el = document.querySelector(`[data-square='${square}']`);
  if (el) el.classList.add(klass);
}

function setLastMove(from, to) {
  lastMoveSquares = { from: from || null, to: to || null };
  applyBoardHighlights();
}

function clearLegalTargets() {
  legalTargetSquares = [];
  applyBoardHighlights();
}

function showLegalTargets(fromSquare) {
  if (!game) return;
  legalTargetSquares = game.moves({ square: fromSquare, verbose: true }).map(m => m.to);
  applyBoardHighlights();
}

function clearHelpPreview() {
  helpPreviewMove = { from: null, to: null };
  if (helpPreviewTimer) {
    clearTimeout(helpPreviewTimer);
    helpPreviewTimer = null;
  }
  applyBoardHighlights();
}

function showHelpPreview(from, to, ttlMs = 2200) {
  helpPreviewMove = { from: from || null, to: to || null };
  if (helpPreviewTimer) clearTimeout(helpPreviewTimer);
  applyBoardHighlights();
  if (ttlMs > 0) {
    helpPreviewTimer = setTimeout(() => {
      helpPreviewTimer = null;
      helpPreviewMove = { from: null, to: null };
      applyBoardHighlights();
    }, ttlMs);
  }
}

function hideEndgameOverlay() {
  const wrap = document.getElementById('endgameOverlay');
  if (wrap) wrap.classList.remove('show');
}

function showEndgameOverlay(title, body) {
  const wrap = document.getElementById('endgameOverlay');
  const t = document.getElementById('endgameOverlayTitle');
  const b = document.getElementById('endgameOverlayBody');
  if (!wrap || !t || !b) return;
  t.textContent = title || 'Game Finished';
  b.textContent = body || '';
  wrap.classList.add('show');
}

function clampNumber(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function updateEloBoardPanel(summaryText) {
  const w = document.getElementById('eloWhite');
  const b = document.getElementById('eloBlack');
  const s = document.getElementById('eloSummary');
  const wr = gameRatings.w && Number.isFinite(gameRatings.w.rating) ? String(Math.round(gameRatings.w.rating)) : '--';
  const br = gameRatings.b && Number.isFinite(gameRatings.b.rating) ? String(Math.round(gameRatings.b.rating)) : '--';
  if (w) w.textContent = wr;
  if (b) b.textContent = br;
  if (s) s.textContent = summaryText || 'Game Rating appears after post-game analysis.';
}

function sideOwnerLabel(colorCode) {
  const sideWord = colorCode === 'w' ? 'White' : 'Black';
  if (!game) return sideWord;
  if (getUserColorCode() === colorCode) return `${sideWord} (You)`;
  return `${sideWord} (${opponentType === 'stockfish' ? 'Stockfish' : 'Computer'})`;
}

function scoreFromMatePly(matePly) {
  const sign = matePly >= 0 ? 1 : -1;
  const dist = Math.abs(matePly);
  return sign * (2000 - Math.min(1900, dist * 10));
}

function normalizeUciLines(raw) {
  if (typeof raw === 'string') {
    return raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }
  if (raw && typeof raw.data === 'string') {
    return raw.data.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }
  if (raw && typeof raw.message === 'string') {
    return raw.message.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }
  if (raw && typeof raw.msg === 'string') {
    return raw.msg.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }
  const txt = String(raw || '').trim();
  return txt ? [txt] : [];
}

function parseUciScore(line) {
  const cp = line.match(/\bscore\s+cp\s+(-?\d+)/);
  if (cp) return parseInt(cp[1], 10);
  const mate = line.match(/\bscore\s+mate\s+(-?\d+)/);
  if (mate) return scoreFromMatePly(parseInt(mate[1], 10));
  return null;
}

function getStockfishFactory() {
  if (typeof STOCKFISH === 'function') return STOCKFISH;
  if (typeof Stockfish === 'function') return Stockfish;
  if (typeof window !== 'undefined') {
    if (typeof window.STOCKFISH === 'function') return window.STOCKFISH;
    if (typeof window.Stockfish === 'function') return window.Stockfish;
    // Some builds (e.g., nmrugg stockfish.js) attach factory on script._exports.
    try {
      const scripts = Array.from(document.getElementsByTagName('script'));
      for (const s of scripts) {
        const src = String(s.src || '');
        if (src.includes('stockfish.js') && typeof s._exports === 'function') return s._exports;
      }
    } catch (_) {}
  }
  return null;
}

function canRunThreadedStockfish() {
  return typeof SharedArrayBuffer !== 'undefined';
}

function canUseWebWorkers() {
  return typeof Worker !== 'undefined';
}

function instantiateStockfishFromFactory(sfFactory) {
  if (typeof sfFactory !== 'function') return null;
  const opts = {
    locateFile: (path) => {
      const name = String(path || '').toLowerCase();
      if (name.endsWith('.wasm')) return './stockfish.wasm';
      if (name.endsWith('stockfish.worker.js')) return './stockfish.worker.js';
      return path;
    }
  };
  try {
    const out = sfFactory(opts);
    if (out != null) return out;
  } catch (_) {}
  // Fallback for factories that do not accept options.
  return sfFactory();
}

function adaptEngineToWorkerLike(engine) {
  if (!engine) return null;
  if (typeof engine.postMessage === 'function' && (typeof engine.onmessage !== 'undefined' || typeof engine.addEventListener === 'function')) {
    return engine;
  }
  if (typeof engine.postMessage === 'function' && typeof engine.addMessageListener === 'function') {
    const wrapped = {
      __sfMainThread: true,
      onmessage: null,
      onerror: null,
      onmessageerror: null,
      postMessage: (msg) => {
        const text = String(msg);
        try {
          // nmrugg/stockfish.js single-thread build expects onCustomMessage.
          if (typeof engine.onCustomMessage === 'function') engine.onCustomMessage(text);
          else if (engine.queue && typeof engine.queue.put === 'function') engine.queue.put(text);
          else if (typeof engine._origOnCustomMessage === 'function') engine._origOnCustomMessage(text);
          else engine.postMessage(text);
        } catch (err) {
          if (wrapped.onerror) wrapped.onerror(err);
        }
      },
      terminate: () => {
        try {
          if (wrapped._listener && typeof engine.removeMessageListener === 'function') {
            engine.removeMessageListener(wrapped._listener);
          }
        } catch (_) {}
        try { engine.terminate && engine.terminate(); } catch (_) {}
      },
      _listener: null
    };
    wrapped._listener = (line) => {
      if (!wrapped.onmessage) return;
      try { wrapped.onmessage({ data: String(line) }); } catch (_) {}
    };
    try { engine.addMessageListener(wrapped._listener); } catch (_) {}
    return wrapped;
  }
  return engine;
}

async function createStockfishWorkerForAnalysis() {
  // Prefer factory first for compatibility with single-thread builds.
  try {
    const sfFactory = getStockfishFactory();
    if (sfFactory) {
      const maybe = instantiateStockfishFromFactory(sfFactory);
      if (maybe && typeof maybe.then === 'function') {
        return adaptEngineToWorkerLike(await maybe);
      }
      return adaptEngineToWorkerLike(maybe);
    }
  } catch (err) {
    try {
      window.__analysisInternal = window.__analysisInternal || [];
      window.__analysisInternal.push([new Date().toISOString(), 'analysis-factory-failed', String(err)]);
    } catch (_) {}
  }

  // Then try worker-backed analysis.
  if (canUseWebWorkers()) {
    const workerCandidates = [
      './stockfish.js#./stockfish-nnue-16-single.wasm,worker',
      './stockfish.js',
      './stockfish.worker.js'
    ];
    for (const src of workerCandidates) {
      try {
        return adaptEngineToWorkerLike(new Worker(src));
      } catch (err) {
        try {
          window.__analysisInternal = window.__analysisInternal || [];
          window.__analysisInternal.push([new Date().toISOString(), 'analysis-worker-candidate-failed', src, String(err)]);
        } catch (_) {}
      }
    }
  }
  return null;
}

function createStockfishAnalyzer() {
  return createStockfishWorkerForAnalysis().then((worker) => {
    if (!worker) return null;
  return new Promise((resolveOuter) => {
    let currentEval = null;
    let evalSeq = 0;
    let settled = false;
    let uciTimer = null;
    let readyTimer = null;

    const send = (msg) => {
      try { worker.postMessage(String(msg)); } catch (_) {}
    };
    const cancelCurrentEval = () => {
      if (!currentEval) return;
      const cb = currentEval.resolve;
      const out = currentEval.score || 0;
      currentEval = null;
      try { cb(out); } catch (_) {}
      try { send('stop'); } catch (_) {}
    };
    const fail = () => {
      if (settled) return;
      settled = true;
      try { worker.terminate && worker.terminate(); } catch (_) {}
      resolveOuter(null);
    };
    const finish = (api) => {
      if (settled) return;
      settled = true;
      resolveOuter(api);
    };

    const evaluateFen = (fen, movetimeMs = 110, depth = null) => {
      if (!fen) return Promise.resolve(0);
      if (currentEval) {
        // Resolve prior in-flight eval before starting a new one.
        cancelCurrentEval();
      }
      return new Promise((resolveEval) => {
        const evalId = ++evalSeq;
        currentEval = { id: evalId, resolve: resolveEval, score: 0 };
        send(`position fen ${fen}`);
        const safeMs = Math.max(60, movetimeMs | 0);
        if (Number.isFinite(depth)) send(`go movetime ${safeMs} depth ${Math.max(4, depth | 0)}`);
        else send(`go movetime ${safeMs}`);
        setTimeout(() => {
          if (!currentEval || currentEval.id !== evalId) return;
          const out = currentEval.score || 0;
          currentEval = null;
          resolveEval(out);
          try { send('stop'); } catch (_) {}
        }, Math.max(260, safeMs + 420));
      });
    };

    worker.onmessage = (e) => {
      const lines = normalizeUciLines(e);
      if (!lines.length) return;
      for (const line of lines) {
        if (/^stockfish\b/i.test(line)) {
          if (uciTimer) clearTimeout(uciTimer);
          if (readyTimer) clearTimeout(readyTimer);
          finish({
            evaluateFen,
            cancelCurrentEval,
            isMainThreadLike: !!worker.__sfMainThread,
            close: () => { try { worker.terminate && worker.terminate(); } catch (_) {} }
          });
          continue;
        }
        if (line.includes('uciok')) {
          if (uciTimer) clearTimeout(uciTimer);
          send('setoption name MultiPV value 1');
          // Some builds are slow or omit readyok; proceed after uciok as fallback.
          if (readyTimer) clearTimeout(readyTimer);
          readyTimer = setTimeout(() => {
            finish({
              evaluateFen,
              cancelCurrentEval,
              isMainThreadLike: !!worker.__sfMainThread,
              close: () => { try { worker.terminate && worker.terminate(); } catch (_) {} }
            });
          }, 1200);
          send('isready');
          continue;
        }
        if (line.includes('readyok')) {
          if (readyTimer) clearTimeout(readyTimer);
          finish({
            evaluateFen,
            cancelCurrentEval,
            isMainThreadLike: !!worker.__sfMainThread,
            close: () => { try { worker.terminate && worker.terminate(); } catch (_) {} }
          });
          continue;
        }
        if (currentEval && line.startsWith('info ')) {
          const sc = parseUciScore(line);
          if (sc !== null) currentEval.score = sc;
          continue;
        }
        if (currentEval && line.startsWith('bestmove')) {
          if (!currentEval) continue;
          const out = currentEval.score || 0;
          const cb = currentEval.resolve;
          currentEval = null;
          cb(out);
          continue;
        }
      }
    };
    worker.onerror = () => fail();
    worker.onmessageerror = () => fail();
    send('uci');
    uciTimer = setTimeout(() => fail(), 9000);
  });
  }).catch(() => null);
}

function turnFromFen(fen) {
  const parts = String(fen || '').split(' ');
  return parts[1] === 'b' ? 'b' : 'w';
}

function buildFallbackGameRatings(scoreWhite) {
  const whiteMoves = moveHistory.reduce((n, _, i) => n + (i > 0 && i % 2 === 1 ? 1 : 0), 0);
  const blackMoves = moveHistory.reduce((n, _, i) => n + (i > 0 && i % 2 === 0 ? 1 : 0), 0);
  const bonusW = scoreWhite === 1 ? 30 : scoreWhite === 0 ? -30 : 0;
  const bonusB = scoreWhite === 0 ? 30 : scoreWhite === 1 ? -30 : 0;
  return {
    w: { rating: clampNumber(1450 + bonusW, 500, 3200), accuracy: 75 + (bonusW / 3), avgCpl: null, moves: whiteMoves },
    b: { rating: clampNumber(1450 + bonusB, 500, 3200), accuracy: 75 + (bonusB / 3), avgCpl: null, moves: blackMoves },
    source: 'fallback'
  };
}

function cplToAccuracy(avgCpl) {
  return clampNumber(100 - (avgCpl * 0.12), 1, 99.9);
}

function accuracyToGameRating(acc) {
  return Math.round(clampNumber(450 + acc * 23.5, 400, 3200));
}

async function analyzeGameRatingsWithStockfish(fens) {
  window.__analysisLastFallbackReason = '';
  if (!Array.isArray(fens) || fens.length < 2) {
    window.__analysisLastFallbackReason = 'invalid-fens';
    return null;
  }
  if (!window.__analysisInternal) window.__analysisInternal = [];
  const atrace = (...a) => {
    try { window.__analysisInternal.push([new Date().toISOString(), ...a]); } catch (_) {}
  };
  const analyzer = await createStockfishAnalyzer();
  if (!analyzer) {
    atrace('no-analyzer');
    window.__analysisLastFallbackReason = 'no-analyzer';
    return null;
  }
  const mainThreadLike = !!analyzer.isMainThreadLike;
  const totalPlies = Math.max(0, fens.length - 1);
  const maxPlies = mainThreadLike ? 16 : 28;
  const stride = Math.max(1, Math.ceil(totalPlies / Math.max(1, maxPlies)));
  const thinkBeforeMs = mainThreadLike ? 24 : 70;
  const thinkAfterMs = mainThreadLike ? 18 : 55;
  const depthBefore = null;
  const depthAfter = null;
  const timeBudgetMs = mainThreadLike ? 2400 : 12000;
  const startTs = Date.now();
  const sampledTotal = Math.max(1, Math.ceil(totalPlies / stride));
  let sampledDone = 0;
  let lastProgressTs = Date.now();
  let abortedForStall = false;
  let stallWatch = null;
  const evalWithDeadline = async (fen, ms, depth, deadlineMs = 1800) => {
    lastProgressTs = Date.now();
    let timedOut = false;
    const val = await Promise.race([
      analyzer.evaluateFen(fen, ms, depth),
      new Promise((resolve) => {
        setTimeout(() => {
          timedOut = true;
          resolve(0);
        }, Math.max(700, deadlineMs));
      })
    ]);
    if (timedOut && analyzer.cancelCurrentEval) analyzer.cancelCurrentEval();
    lastProgressTs = Date.now();
    return Number.isFinite(val) ? val : 0;
  };
  const stats = {
    w: { cpl: 0, moves: 0 },
    b: { cpl: 0, moves: 0 }
  };
  try {
    atrace('start', { totalPlies, stride, sampledTotal, mainThreadLike });
    stallWatch = setInterval(() => {
      if ((Date.now() - lastProgressTs) > 3200) {
        abortedForStall = true;
        lastProgressTs = Date.now();
        try { analyzer.cancelCurrentEval && analyzer.cancelCurrentEval(); } catch (_) {}
        atrace('stall-watchdog-fired');
      }
    }, 300);
    for (let i = 1; i < fens.length; i += stride) {
      if (abortedForStall) {
        window.__analysisLastFallbackReason = 'stall-watchdog';
        return null;
      }
      if ((Date.now() - startTs) > timeBudgetMs) {
        window.__analysisLastFallbackReason = 'time-budget';
        return null;
      }
      sampledDone += 1;
      if (sampledDone === 1 || sampledDone % 4 === 0 || sampledDone === sampledTotal) {
        updateEloBoardPanel(`Analyzing game with Stockfish... ${sampledDone}/${sampledTotal}`);
      }
      // Yield so paint/input can run while long analysis continues.
      await new Promise(resolve => setTimeout(resolve, 0));
      const beforeFen = fens[i - 1];
      const afterFen = fens[i];
      const mover = turnFromFen(beforeFen);
      atrace('ply-start', i, mover);
      const bestBefore = await evalWithDeadline(beforeFen, thinkBeforeMs, depthBefore, 1800);
      const afterRaw = await evalWithDeadline(afterFen, thinkAfterMs, depthAfter, 1800);
      const afterFromMover = -afterRaw;
      const cpl = clampNumber(Math.max(0, bestBefore - afterFromMover), 0, 600);
      stats[mover].cpl += cpl;
      stats[mover].moves += stride;
      atrace('ply-end', i, cpl);
    }
  } finally {
    if (stallWatch) clearInterval(stallWatch);
    analyzer.close();
  }
  atrace('complete', stats);
  if (stats.w.moves + stats.b.moves < 8) {
    window.__analysisLastFallbackReason = 'insufficient-samples';
    return null;
  }
  const build = (color) => {
    const moves = stats[color].moves || 0;
    const avgCpl = moves > 0 ? (stats[color].cpl / moves) : 120;
    const accuracy = cplToAccuracy(avgCpl);
    const rating = accuracyToGameRating(accuracy);
    return { rating, accuracy, avgCpl, moves };
  };
  return { w: build('w'), b: build('b'), source: 'stockfish' };
}

function formatSideGameRatingLine(colorCode) {
  const label = sideOwnerLabel(colorCode);
  const side = gameRatings[colorCode] || {};
  const rt = Number.isFinite(side.rating) ? Math.round(side.rating) : '--';
  const acc = Number.isFinite(side.accuracy) ? `${side.accuracy.toFixed(1)}%` : '--';
  return `${label} Game Rating: ${rt} (Accuracy ${acc})`;
}

async function finalizeGameRatings(reasonText, scoreWhite, sessionIdAtEnd) {
  const fens = moveHistory.slice();
  updateEloBoardPanel(`${reasonText}. Analyzing game with Stockfish...`);
  showEndgameOverlay('Game Finished', `${reasonText}. Running post-game analysis...`);
  let analyzeTimedOut = false;
  const analyzed = await Promise.race([
    analyzeGameRatingsWithStockfish(fens),
    new Promise((resolve) => setTimeout(() => {
      analyzeTimedOut = true;
      resolve(null);
    }, 12000))
  ]);
  if (sessionIdAtEnd !== gameSessionId) return;

  if (analyzed) gameRatings = analyzed;
  else gameRatings = buildFallbackGameRatings(scoreWhite);

  let fallbackReason = '';
  try { fallbackReason = String(window.__analysisLastFallbackReason || '').trim(); } catch (_) {}
  if (analyzeTimedOut) fallbackReason = 'finalize-timeout';
  const sourceText = analyzed
    ? 'Stockfish analysis complete.'
    : `Stockfish unavailable; using fallback estimate${fallbackReason ? ` (${fallbackReason})` : ''}.`;
  const summary = `${reasonText}. ${formatSideGameRatingLine('w')}. ${formatSideGameRatingLine('b')}. ${sourceText}`;
  updateEloBoardPanel(summary);
  showEndgameOverlay('Game Finished', summary);
  log(summary);
  alert(summary);
}

function handleGameEnd(reasonCode, lastMoverColor) {
  if (gameResultHandled) return;
  let scoreWhite = 0.5;
  let reason = 'Game ended';
  let statusKind = 'state-draw';
  if (reasonCode === 'checkmate') {
    const winner = (lastMoverColor === 'w') ? 'White' : 'Black';
    scoreWhite = (lastMoverColor === 'w') ? 1 : 0;
    reason = `${winner} wins by checkmate`;
    statusKind = 'state-win';
  } else if (reasonCode === 'stalemate') {
    scoreWhite = 0.5;
    reason = 'Draw by stalemate';
  } else if (reasonCode === 'threefold') {
    scoreWhite = 0.5;
    reason = 'Draw by threefold repetition';
  } else if (reasonCode === 'fifty') {
    scoreWhite = 0.5;
    reason = 'Draw by 50-move rule';
  } else if (reasonCode === 'insufficient') {
    scoreWhite = 0.5;
    reason = 'Draw by insufficient material';
  } else if (reasonCode === 'draw') {
    scoreWhite = 0.5;
    reason = 'Draw';
  }
  gameStatusOverride = {
    text: `State: ${reason}`,
    kind: statusKind
  };
  stopClockTicker();
  clearAiVsAiTimer();
  gameActive = false;
  gameResultHandled = true;
  log(reason + '.');
  const sessionAtEnd = gameSessionId;
  finalizeGameRatings(reason, scoreWhite, sessionAtEnd).catch((err) => {
    console.error('Game rating analysis failed:', err);
    if (sessionAtEnd !== gameSessionId) return;
    gameRatings = buildFallbackGameRatings(scoreWhite);
    const summary = `${reason}. ${formatSideGameRatingLine('w')}. ${formatSideGameRatingLine('b')}.`;
    updateEloBoardPanel(summary);
    showEndgameOverlay('Game Finished', summary);
  });
}

function setDemoPreview(from, to) {
  applyBoardHighlights();
  if (from) highlightByClass(from, 'sq-demo-from');
  if (to) highlightByClass(to, 'sq-demo-to');
}

function clearDemoPreview() {
  document.querySelectorAll('[data-square].sq-demo-from, [data-square].sq-demo-to').forEach(el => {
    el.classList.remove('sq-demo-from', 'sq-demo-to');
  });
}

function setDemoOverlayVisible(show) {
  const wrap = document.getElementById('demoOverlay');
  if (!wrap) return;
  wrap.classList.toggle('show', !!show);
}

function askDemoStepOnBoard(cfg) {
  const wrap = document.getElementById('demoOverlay');
  const title = document.getElementById('demoOverlayTitle');
  const body = document.getElementById('demoOverlayBody');
  const moveLine = document.getElementById('demoOverlayMove');
  const question = document.getElementById('demoOverlayQuestion');
  const yesBtn = document.getElementById('demoYesBtn');
  const noBtn = document.getElementById('demoNoBtn');
  if (!wrap || !title || !body || !moveLine || !question || !yesBtn || !noBtn) {
    return Promise.resolve(window.confirm('Show next special move?'));
  }

  clearDemoPreview();
  setDemoPreview(cfg.from, cfg.to);
  title.textContent = cfg.title || 'Special Move';
  body.textContent = cfg.body || '';
  moveLine.textContent = cfg.moveText || '';
  question.textContent = cfg.question || 'Show this move?';
  yesBtn.textContent = cfg.yesLabel || 'Yes';
  noBtn.textContent = cfg.noLabel || 'No';
  // Prevent accidental carry-over click/tap from previous dialog.
  demoDialogArmedAt = Date.now() + 180;
  setDemoOverlayVisible(true);

  return new Promise(resolve => {
    demoDecisionResolver = (answer) => {
      demoDecisionResolver = null;
      resolve(answer);
    };
  });
}

function closeDemoOverlay() {
  demoDecisionResolver = null;
  setDemoOverlayVisible(false);
  clearDemoPreview();
}

function setupDemoOverlayDrag() {
  const overlay = document.getElementById('demoOverlay');
  const handle = document.getElementById('demoOverlayTitle');
  if (!overlay || !handle) return;
  handle.classList.add('demo-drag-handle');

  handle.addEventListener('pointerdown', (e) => {
    if (!overlay.classList.contains('show')) return;
    const rect = overlay.getBoundingClientRect();
    demoDragState.active = true;
    demoDragState.dx = e.clientX - rect.left;
    demoDragState.dy = e.clientY - rect.top;
    try { handle.setPointerCapture(e.pointerId); } catch (_) {}
    e.preventDefault();
  });

  const stopDrag = () => { demoDragState.active = false; };
  window.addEventListener('pointerup', stopDrag);
  window.addEventListener('pointercancel', stopDrag);
  window.addEventListener('pointermove', (e) => {
    if (!demoDragState.active) return;
    let left = e.clientX - demoDragState.dx;
    let top = e.clientY - demoDragState.dy;
    const maxLeft = Math.max(0, window.innerWidth - overlay.offsetWidth - 8);
    const maxTop = Math.max(0, window.innerHeight - overlay.offsetHeight - 8);
    left = Math.max(0, Math.min(left, maxLeft));
    top = Math.max(0, Math.min(top, maxTop));
    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
  });
}

function updateTurnInfo() {
  if (!game) {
    document.getElementById('turnInfo').textContent = '';
    updateStatusBar();
    refreshCaptureAndMaterialUI();
    updateHelpInfo();
    updateResignButtonState();
    return;
  }
  const t = game.turn() === 'w' ? 'White' : 'Black';
  const sideTxt = isAiVsAiActive() ? 'Watching AI vs AI' : `You are ${userSide === 'black' ? 'Black' : 'White'}`;
  const levelTxt = `Level: ${getAiLevelConfig().label}`;
  let oppTxt;
  if (isAiVsAiActive()) {
    oppTxt = `White=${aiVsAiEngines.w === 'stockfish' ? 'Stockfish' : 'Local AI'}, Black=${aiVsAiEngines.b === 'stockfish' ? 'Stockfish' : 'Local AI'}`;
  } else if (opponentType === 'stockfish') oppTxt = 'Opponent: Stockfish (single-thread)';
  else oppTxt = 'Opponent: Local AI';
  document.getElementById('turnInfo').textContent = `${t} to move • ${sideTxt} • ${oppTxt} • ${levelTxt}`;
  document.getElementById('specialStatus').textContent = buildSpecialStatusText();
  updateStatusBar();
  refreshCaptureAndMaterialUI();
  applyBoardHighlights();
  updateHelpInfo();
  updateResignButtonState();
}

function getUserColorCode() {
  return userSide === 'white' ? 'w' : 'b';
}

function tickShadowCooldownFor(colorCode) {
  if (playerSpecialState[colorCode].shadowCooldown > 0) {
    playerSpecialState[colorCode].shadowCooldown = Math.max(0, playerSpecialState[colorCode].shadowCooldown - 1);
  }
}

function trackCapturedFromMove(move) {
  if (!move || !move.captured) return;
  const victimColor = (move.color === 'w') ? 'b' : 'w';
  lostPieces[victimColor].push(move.captured);
}

function isFiftyMoveDrawState() {
  if (!game) return false;
  const half = parseInt((game.fen().split(' ')[4] || '0'), 10);
  return half >= 100;
}

function postMoveChecksAndFlow(lastMoverColor) {
  clearHelpPreview();
  updateTurnInfo();
  refreshSpecialButtons();

  // Demo should not trigger game-end overlays or post-game analysis.
  if (isDemoRunning) {
    if (game && game.in_check && game.in_check()) {
      log(`${game.turn() === 'w' ? 'White' : 'Black'} is in check.`);
    }
    return;
  }

  if (game.in_checkmate()) {
    handleGameEnd('checkmate', lastMoverColor);
    return;
  }
  if (game.in_stalemate()) {
    handleGameEnd('stalemate', lastMoverColor);
    return;
  }
  if (game.in_threefold_repetition()) {
    handleGameEnd('threefold', lastMoverColor);
    return;
  }
  if (typeof game.insufficient_material === 'function' && game.insufficient_material()) {
    handleGameEnd('insufficient', lastMoverColor);
    return;
  }
  if (isFiftyMoveDrawState()) {
    handleGameEnd('fifty', lastMoverColor);
    return;
  }
  if (game.in_draw()) {
    handleGameEnd('draw', lastMoverColor);
    return;
  }
  if (game.in_check()) {
    log(`${game.turn() === 'w' ? 'White' : 'Black'} is in check.`);
  }

  if (isAiVsAiActive()) {
    scheduleAiVsAiMove();
    startClockFor(game.turn());
    return;
  }

  const myColor = getUserColorCode();
  if (!game.game_over() && game.turn() !== myColor) {
    console.log('[AI] Triggering opponent move. Opponent type =', opponentType);
    if (opponentType === 'stockfish' && sfWorker) {
      try { sfWantGo = true; sfWorker.postMessage('isready'); } catch (_) {}
    }
    setTimeout(() => maybeAIMove(), 150);
  }
  startClockFor(game.turn());
}

function buildSpecialStatusText() {
  const t = playerSpecialState;
  return `White: swapUsed=${t.w.swapUsed} shadowCD=${t.w.shadowCooldown} backUsed=${t.w.backInTimeUsed} resurrect=${t.w.resurrectionUsed}
Black: swapUsed=${t.b.swapUsed} shadowCD=${t.b.shadowCooldown} backUsed=${t.b.backInTimeUsed} resurrect=${t.b.resurrectionUsed}`;
}

function refreshSpecialButtons() {
  const ctr = document.getElementById('specialButtons');
  ctr.innerHTML = '';
  const cfg = modeConfig;
  if (!cfg) { ctr.textContent = 'Start a game to see special moves.'; return; }

  const btn = (id, label, handler) => {
    const b = document.createElement('button');
    b.id = id; b.textContent = label; b.addEventListener('click', handler); ctr.appendChild(b);
  };

  // Mild
  if (cfg.swapMove) btn('swapBtn','Swap (Switcheroo)', onSwapClick);
  if (cfg.pawnPromotionAnywhere) btn('pawnPromoBtn','Pawn-Promote-on-Capture (auto)', () => alert('Enabled: whenever a pawn captures, you can promote immediately.'));

  // Medium
  if (cfg.shadowStep) btn('shadowBtn','Shadow Step (knight blink)', onShadowClick);
  if (cfg.resurrection) btn('resurrectBtn','Resurrect captured piece', onResurrectClick);

  // Chaotic
  if (cfg.backInTime) btn('backBtn','Back In Time (undo opponent last)', onBackInTimeClick);

  document.getElementById('specialStatus').textContent = buildSpecialStatusText();
}

/* =========================
   Multi-CDN Chessboard.js loader
   ========================= */
function loadScript(src, onload, onerror) {
  const s = document.createElement('script');
  s.src = src;
  s.async = true;
  s.onload = onload;
  s.onerror = onerror || function() { console.error('Failed to load script:', src); };
  document.head.appendChild(s);
}
function tryLoadChessboard(next) {
  const candidates = [
    './vendor/chessboard-0.3.0.min.js'
  ];
  let i = 0;
  const tryNext = () => {
    if (typeof Chessboard !== 'undefined') { return next && next(); }
    if (i >= candidates.length) { alert('Could not load local Chessboard.js (./vendor/chessboard-0.3.0.min.js).'); return; }
    const url = candidates[i++];
    loadScript(url, () => setTimeout(() => {
      if (typeof Chessboard !== 'undefined') { next && next(); }
      else { tryNext(); }
    }, 0), () => tryNext());
  };
  tryNext();
}

/* =========================
   Inline SVG pieces fallback (no CDN needed)
   ========================= */
function pieceSvgDataURI(pieceCode) {
  const isWhite = pieceCode[0] === 'w';
  const type = pieceCode[1].toLowerCase();
  const fill = isWhite ? '#ffffff' : '#111111';
  const stroke = isWhite ? '#111111' : '#eeeeee';
  const accent = isWhite ? '#dddddd' : '#333333';
  const wrap = (content) =>
    'data:image/svg+xml;utf8,' + encodeURIComponent(
      `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">` + content + `</svg>`
    );
  const baseShadow = `<ellipse cx="128" cy="220" rx="90" ry="12" fill="${accent}" opacity="0.25"/>`;
  if (type === 'p') return wrap(baseShadow + `<circle cx="128" cy="82" r="26" fill="${fill}" stroke="${stroke}" stroke-width="8"/><path d="M96 116 h64 v20 c0 9 -7 16 -16 16 h-32 c-9 0 -16 -7 -16 -16 z" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="92" y="156" width="72" height="20" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="80" y="184" width="96" height="22" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  if (type === 'r') return wrap(baseShadow + `<path d="M80 72 h96 v24 h-16 v20 h-16 v-20 h-16 v20 h-16 v-20 h-16 z" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="80" y="112" width="96" height="88" rx="8" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="72" y="204" width="112" height="20" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  if (type === 'n') return wrap(baseShadow + `<path d="M176 176 c-8 20 -28 30 -52 30 h-48 v-22 h34 c12 0 18 -6 18 -14 v-18 l-30 -22 l12 -18 l34 18 c6 4 10 2 12 -2 l10 -24 c4 -10 -2 -16 -10 -20 l-30 -14 8 -20 36 12 c20 8 34 30 26 52 l-8 24 18 14 c10 8 10 24 0 34z" fill="${fill}" stroke="${stroke}" stroke-width="8" stroke-linejoin="round"/><rect x="72" y="204" width="112" height="20" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  if (type === 'b') return wrap(baseShadow + `<path d="M128 56 a22 22 0 1 1 0 44 a22 22 0 1 1 0 -44z" fill="${fill}" stroke="${stroke}" stroke-width="8"/><path d="M100 120 c0 -22 22 -32 28 -32 h0 c6 0 28 10 28 32 c0 14 -8 20 -14 26 c-6 6 -10 10 -10 18 v14 h-8 v-14 c0 -8 -4 -12 -10 -18 c-6 -6 -14 -12 -14 -26z" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="92" y="182" width="72" height="16" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="76" y="202" width="104" height="18" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  if (type === 'q') return wrap(baseShadow + `<circle cx="64" cy="76" r="12" fill="${fill}" stroke="${stroke}" stroke-width="8"/><circle cx="112" cy="56" r="12" fill="${fill}" stroke="${stroke}" stroke-width="8"/><circle cx="144" cy="56" r="12" fill="${fill}" stroke="${stroke}" stroke-width="8"/><circle cx="192" cy="76" r="12" fill="${fill}" stroke="${stroke}" stroke-width="8"/><path d="M80 92 h96 l-16 72 h-64 z" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="88" y="170" width="80" height="18" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="76" y="194" width="104" height="20" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  if (type === 'k') return wrap(baseShadow + `<rect x="120" y="40" width="16" height="28" fill="${fill}" stroke="${stroke}" stroke-width="8"/><rect x="108" y="56" width="40" height="16" fill="${fill}" stroke="${stroke}" stroke-width="8"/><path d="M88 88 h80 l-12 36 c12 10 20 24 20 40 c0 28 -22 50 -48 50 h-40 c-26 0 -48 -22 -48 -50 c0 -16 8 -30 20 -40 l-12 -36 z" fill="${fill}" stroke="${stroke}" stroke-width="8" stroke-linejoin="round"/><rect x="76" y="194" width="104" height="20" rx="6" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
  return wrap(baseShadow + `<circle cx="128" cy="128" r="96" fill="${fill}" stroke="${stroke}" stroke-width="8"/>`);
}

/* =========================
   Realistic piece set resolver (Staunton SVGs)
   ========================= */
const REALISTIC_PIECES = {
  wp: './vendor/pieces/wp.svg',
  wr: './vendor/pieces/wr.svg',
  wn: './vendor/pieces/wn.svg',
  wb: './vendor/pieces/wb.svg',
  wq: './vendor/pieces/wq.svg',
  wk: './vendor/pieces/wk.svg',
  bp: './vendor/pieces/bp.svg',
  br: './vendor/pieces/br.svg',
  bn: './vendor/pieces/bn.svg',
  bb: './vendor/pieces/bb.svg',
  bq: './vendor/pieces/bq.svg',
  bk: './vendor/pieces/bk.svg'
};

function resolveRealisticPieces(done) {
  const probe = new Image();
  probe.onload = () => done(REALISTIC_PIECES);
  probe.onerror = () => done(null);
  probe.src = REALISTIC_PIECES.wp;
}

/* =========================
   Coordinate labels
   ========================= */
function setupBoardLabels() {
  const r = document.getElementById('rankLabels');
  const f = document.getElementById('fileLabels');
  if (!r || !f) return;
  r.innerHTML = '';
  f.innerHTML = '';
  const isBlackBottom = userSide === 'black';
  const ranks = isBlackBottom ? [8,7,6,5,4,3,2,1] : [1,2,3,4,5,6,7,8];
  const files = isBlackBottom ? ['h','g','f','e','d','c','b','a'] : ['a','b','c','d','e','f','g','h'];
  for (const rank of ranks) { const d = document.createElement('div'); d.textContent = String(rank); r.appendChild(d); }
  for (const ch of files) { const d = document.createElement('div'); d.textContent = ch; f.appendChild(d); }
}

function configureStockfishForLevel(worker) {
  if (!worker) return;
  const send = worker._send ? worker._send : (m)=>{ try{ worker.postMessage(m);}catch(_){ } };
  const cfg = getAiLevelConfig().stockfish;
  send(`setoption name Skill Level value ${cfg.skill}`);
  send('setoption name UCI_LimitStrength value true');
  send(`setoption name UCI_Elo value ${cfg.elo}`);
}

function sendStockfishGo(worker, fen) {
  if (!worker || !fen) return;
  const send = worker._send ? worker._send : (m)=>{ try{ worker.postMessage(m);}catch(_){ } };
  const cfg = getAiLevelConfig().stockfish;
  sfInitStartedTs = 0;
  sfLastGoFen = fen;
  sfLastGoTs = Date.now();
  if (sfBestmoveTimer) { clearTimeout(sfBestmoveTimer); sfBestmoveTimer = null; }
  send(`position fen ${fen}`);
  send(`go movetime ${cfg.movetimeMs}`);
  sfBestmoveTimer = setTimeout(() => {
    forceStockfishFallbackMove('Stockfish did not respond in time');
  }, Math.max(2200, cfg.movetimeMs + 1400));
}

function forceStockfishFallbackMove(reasonText) {
  if (!game || game.game_over()) return;
  if (!isAiVsAiActive() && opponentType !== 'stockfish' && !sfDisabled) return;
  if (!isAiVsAiActive()) {
    const myColor = getUserColorCode();
    if (game.turn() === myColor) return;
  }
  sfInitInProgress = false;
  sfInitStartedTs = 0;
  if (sfBestmoveTimer) { clearTimeout(sfBestmoveTimer); sfBestmoveTimer = null; }
  log(`${reasonText}; using local fallback move.`);
  aiMoveLocalGreedy();
}

/* =========================
   Start game & board hooks
   ========================= */
function startGame() {
  gameSessionId += 1;
  boardReadySessionId = 0;
  clearAiVsAiTimer();
  clearReplayTimer();
  replayModeActive = false;
  replayPly = 0;
  closeDemoOverlay();
  hideEndgameOverlay();
  clearHelpPreview();
  clearSquareInteractionHandlers();
  resetTouchMoveSelection();
  modeName = document.getElementById('modeSelect').value;
  modeConfig = gameModes[modeName];
  gameType = (document.getElementById('gameTypeSelect')?.value || 'human_vs_ai');
  userSide = (document.getElementById('sideSelect')?.value || 'white');
  aiVsAiEngines = {
    w: (document.getElementById('aiWhiteEngineSelect')?.value || 'local'),
    b: (document.getElementById('aiBlackEngineSelect')?.value || 'local')
  };
  aiVsAiMoveDelayMs = parseInt((document.getElementById('aiVsAiSpeedSelect')?.value || '500'), 10) || 500;
  setupBoardLabels();
  opponentType = (document.getElementById('opponentSelect')?.value || 'local');
  aiLevel = (document.getElementById('levelSelect')?.value || 'intermediate');
  helpMode = (document.getElementById('helpSelect')?.value || 'off');
  timeControl = (document.getElementById('timeControlSelect')?.value || 'rapid');
  updateGameTypeUI();
  updateOpponentHint();

  // Always stop any previous engine before starting a new game.
  if (sfWorker) {
    try { sfWorker.terminate && sfWorker.terminate(); } catch (_) {}
    sfWorker = null;
  }
  sfReady = false;
  sfWantGo = false;
  sfLastGoFen = '';
  sfLastGoTs = 0;
  sfInitInProgress = false;
  sfInitStartedTs = 0;
  sfDisabled = false;
  if (sfBestmoveTimer) { clearTimeout(sfBestmoveTimer); sfBestmoveTimer = null; }

  // Stockfish worker setup if needed
  if (opponentType === 'stockfish' || aiVsAiNeedsStockfish()) {
    const startSessionId = gameSessionId;
    let sfRecoveryAttempts = 0;
    const sfMaxRecoveryAttempts = 3;
    function attachSFHandlers(worker){
      worker.onmessage = (e) => {
        const lines = normalizeUciLines(e);
        if (!lines.length) return;
        for (const line of lines) {
          console.debug('[SF line]', line);
          if (/^stockfish\b/i.test(line)) {
            // Some builds emit only a banner line and do not reliably echo uciok/readyok.
            sfReady = true;
            sfInitInProgress = false;
            sfInitStartedTs = 0;
            if (sfWantGo && game) {
              sfWantGo = false;
              sendStockfishGo(worker, game.fen());
            }
            continue;
          }
          if (line.includes('uciok')) {
            configureStockfishForLevel(worker);
            // Some wrappers never emit readyok; treat uciok as ready enough to search.
            sfReady = true;
            sfInitInProgress = false;
            sfInitStartedTs = 0;
            if (!sfWantGo) { try { worker.postMessage('isready'); } catch(_) {} }
            if (sfWantGo && game) {
              sfWantGo = false;
              sendStockfishGo(worker, game.fen());
            }
            continue;
          }
          if (line.includes('readyok')) {
            sfReady = true;
            sfInitInProgress = false;
            sfInitStartedTs = 0;
            console.log('[SF] readyok');
            if (sfWantGo && game) {
              sfWantGo = false;
              const fen = game.fen();
              console.log('[SF] sending position + go');
              sendStockfishGo(worker, fen);
            }
            continue;
          }

          if (line.includes('bestmove')) {
            if (opponentType !== 'stockfish' || !game || game.game_over()) return;
            if (sfLastGoFen && game.fen() !== sfLastGoFen) {
              console.log('[SF] Ignoring stale bestmove for old position');
              continue;
            }
            const match = line.match(/bestmove\s+([a-h][1-8][a-h][1-8][qrbn]?)/i);
            const uci = match ? match[1].toLowerCase() : '';
            if (uci && uci.length >= 4) {
              if (sfBestmoveTimer) { clearTimeout(sfBestmoveTimer); sfBestmoveTimer = null; }
              const from = uci.slice(0,2), to = uci.slice(2,4), promo = uci.slice(4) || undefined;
              try {
                const mv = game.move({ from, to, promotion: promo });
                if (mv) {
                  trackCapturedFromMove(mv);
                  tickShadowCooldownFor(mv.color);
                  board.position(game.fen());
                  setLastMove(mv.from, mv.to);
                  appendHistoryEntry(mv.san);
                  halfMoveCount++;
                  sfLastGoFen = '';
                  log(`Opponent (Stockfish): ${mv.san}`);
                  postMoveChecksAndFlow(mv.color);
                }
              } catch(_) {}
            } else {
              console.warn('[SF] bestmove received but could not parse move:', line);
            }
            continue;
          }
        }
      };
      // Normalize a send() helper for logging
      if (!worker._send) {
        worker._send = (msg) => {
          try { worker.postMessage(msg); } catch (err) { console.warn('[SF send error]', err, msg); }
        };
      }
    }

    const recoverStockfishAfterFailure = (failedSource, reasonText) => {
      if (startSessionId !== gameSessionId) return;
      if (sfDisabled) return;
      if (sfReady) return;
      if (sfRecoveryAttempts >= sfMaxRecoveryAttempts) {
        console.warn('[SF] Recovery exhausted:', reasonText);
        sfDisabled = true;
        sfInitInProgress = false;
        sfInitStartedTs = 0;
        if (sfWorker) {
          try { sfWorker.terminate && sfWorker.terminate(); } catch (_) {}
          sfWorker = null;
        }
        if (opponentType === 'stockfish') {
          opponentType = 'local';
          const oppSel = document.getElementById('opponentSelect');
          if (oppSel) oppSel.value = 'local';
          updateOpponentHint();
          updateTurnInfo();
        }
        log('Stockfish unavailable; switched to Local AI for this game.');
        forceStockfishFallbackMove('Stockfish engine failed; using local fallback');
        return;
      }
      sfRecoveryAttempts += 1;
      sfInitInProgress = false;
      sfInitStartedTs = 0;
      const tryBind = (w, label, source) => {
        try {
          bindAndStartWorker(w, label, source);
          return true;
        } catch (err) {
          console.warn('[SF] Recovery candidate failed:', label, err);
          return false;
        }
      };
      if (canRunThreadedStockfish() && window.Worker && failedSource !== 'worker-js') {
        if (tryBind(new Worker('./stockfish.js'), '[SF] Recovery worker started (stockfish.js)', 'worker-js')) return;
      }
      if (canRunThreadedStockfish() && window.Worker && failedSource !== 'worker-workerjs') {
        if (tryBind(new Worker('./stockfish.worker.js'), '[SF] Recovery worker started (stockfish.worker.js)', 'worker-workerjs')) return;
      }
      const sfFactory = getStockfishFactory();
      if (sfFactory && failedSource !== 'factory') {
        try {
          const maybe = instantiateStockfishFromFactory(sfFactory);
          if (maybe && typeof maybe.then === 'function') {
            maybe.then((w) => {
              if (!w || startSessionId !== gameSessionId || sfReady) return;
              tryBind(w, '[SF] Recovery engine resolved via STOCKFISH() factory', 'factory');
            }).catch((err) => {
              console.warn('[SF] Recovery STOCKFISH() failed:', err);
            });
            return;
          }
          if (maybe && tryBind(maybe, '[SF] Recovery engine via STOCKFISH() factory', 'factory')) return;
        } catch (err) {
          console.warn('[SF] Recovery STOCKFISH() threw:', err);
        }
      }
      forceStockfishFallbackMove('Stockfish recovery failed; using local fallback');
    };

    function startSF(worker){
      attachSFHandlers(worker);
      sfInitStartedTs = Date.now();

      // Error + messageerror diagnostics
      worker.onerror = (e) => {
        console.error('[SF worker.onerror]', e.message || e);
        if (sfWorker === worker) sfWorker = null;
        try { worker.terminate && worker.terminate(); } catch (_) {}
        recoverStockfishAfterFailure(worker._sfSource || 'unknown', 'worker error');
      };
      worker.onmessageerror = (e) => {
        console.error('[SF worker.onmessageerror]', e);
        if (sfWorker === worker) sfWorker = null;
        try { worker.terminate && worker.terminate(); } catch (_) {}
        recoverStockfishAfterFailure(worker._sfSource || 'unknown', 'worker messageerror');
      };

      // Send UCI init in multiple formats to cover different builds
      try { worker.postMessage('uci'); } catch(_) {}
      try { worker.postMessage('ucinewgame'); } catch(_) {}

      // Kick readiness now and keep pinging until ready (max 10s)
      const startTs = Date.now();
      const ping = () => {
        if (sfDisabled || startSessionId !== gameSessionId) return;
        if (sfReady) return; // stop when ready
        const elapsed = Date.now() - startTs;
        if (elapsed > 15000) {
          console.warn('[SF] ready ping timeout (>15s)');
          if (sfWorker === worker) sfWorker = null;
          try { worker.terminate && worker.terminate(); } catch (_) {}
          recoverStockfishAfterFailure(worker._sfSource || 'unknown', 'ready ping timeout');
          return;
        }
        try { worker.postMessage('isready'); } catch(_) {}
        setTimeout(ping, 300);
      };
      setTimeout(ping, 50);
    }

    const bindAndStartWorker = (worker, label, source = 'unknown') => {
      if (!worker) throw new Error('Stockfish worker not created');
      const adapted = adaptEngineToWorkerLike(worker);
      if (!adapted) throw new Error('Stockfish engine could not be adapted');
      if (startSessionId !== gameSessionId) {
        try { adapted.terminate && adapted.terminate(); } catch (_) {}
        return;
      }
      adapted._sfSource = source;
      sfWorker = adapted;
      sfInitInProgress = true;
      console.log(label);
      startSF(adapted);
    };

    const tryWorkerStartupFallback = () => {
      if (startSessionId !== gameSessionId) return;
      if (sfWorker || sfReady) return;
      if (!canRunThreadedStockfish()) return;
      if (!window.Worker) return;
      try {
        bindAndStartWorker(new Worker('./stockfish.worker.js'), '[SF] Fallback worker started (stockfish.worker.js)', 'worker-workerjs');
      } catch (_) {
        try {
          bindAndStartWorker(new Worker('./stockfish.js'), '[SF] Fallback worker started (stockfish.js)', 'worker-js');
        } catch (err) {
          console.error('[SF] Fallback worker startup failed', err);
        }
      }
    };

    try {
      const sfFactory = getStockfishFactory();
      if (sfFactory) {
        let maybeEngine = null;
        try {
          maybeEngine = instantiateStockfishFromFactory(sfFactory);
        } catch (factoryErr) {
          if (!canRunThreadedStockfish()) {
            throw new Error('Installed Stockfish build requires SharedArrayBuffer. Use a non-threaded stockfish.js build for GitHub Pages.');
          }
          throw factoryErr;
        }
        if (maybeEngine && typeof maybeEngine.then === 'function') {
          sfInitInProgress = true;
          sfInitStartedTs = Date.now();
          const asyncInitTimer = setTimeout(() => {
            if (startSessionId !== gameSessionId) return;
            if (sfWorker || sfReady) return;
            console.warn('[SF] Async STOCKFISH() startup timed out; trying Worker fallback');
            sfInitInProgress = false;
            tryWorkerStartupFallback();
          }, 8000);
          maybeEngine.then((resolvedWorker) => {
            clearTimeout(asyncInitTimer);
            if (startSessionId !== gameSessionId) {
              try { resolvedWorker && resolvedWorker.terminate && resolvedWorker.terminate(); } catch (_) {}
              return;
            }
            if (sfWorker || sfReady) {
              try { resolvedWorker && resolvedWorker.terminate && resolvedWorker.terminate(); } catch (_) {}
              return;
            }
            bindAndStartWorker(resolvedWorker, '[SF] Engine resolved via async STOCKFISH() factory', 'factory');
          }).catch((err) => {
            clearTimeout(asyncInitTimer);
            sfInitInProgress = false;
            console.error('[SF] Async STOCKFISH() init failed', err);
            tryWorkerStartupFallback();
          });
        } else {
          bindAndStartWorker(maybeEngine, '[SF] Engine created via STOCKFISH() factory', 'factory');
        }
      } else if (canRunThreadedStockfish() && window.Worker) {
        try {
          bindAndStartWorker(new Worker('./stockfish.worker.js'), '[SF] Worker started (stockfish.worker.js)', 'worker-workerjs');
        } catch (_) {
          bindAndStartWorker(new Worker('./stockfish.js'), '[SF] Worker started (stockfish.js)', 'worker-js');
        }
      } else {
        throw new Error('No compatible Stockfish engine found (factory missing, and threaded workers unavailable).');
      }
    } catch (err) {
      sfInitInProgress = false;
      sfInitStartedTs = 0;
      console.error('Failed to start Stockfish. Ensure correct build/files are present.', err);
      if (!canRunThreadedStockfish()) {
        sfDisabled = true;
        if (opponentType === 'stockfish') {
          opponentType = 'local';
          const oppSelNoSab = document.getElementById('opponentSelect');
          if (oppSelNoSab) oppSelNoSab.value = 'local';
          updateOpponentHint();
        }
        log('Stockfish disabled: current build needs SharedArrayBuffer. Install non-threaded stockfish.js for GitHub Pages.');
      } else {
        alert('Could not start Stockfish worker. Check console for details.');
      }
    }

    // Diagnostic: only ping WASM when served via http(s)
    if (location.protocol.startsWith('http')) {
      fetch('./stockfish.wasm', { method: 'HEAD' }).then(r => {
        if (!r.ok) console.warn('stockfish.wasm HEAD status:', r.status);
      }).catch(err => console.warn('stockfish.wasm not reachable:', err));
    }
  }

  game = new Chess();

  resolveRealisticPieces((pieceSet) => {
    const useInline = !pieceSet;
    boardConfig = {
      // Hybrid devices (fine + touch) keep drag, touch-only devices use tap-to-move.
      draggable: !!inputCapabilities.hasFine,
      position: 'start',
      onDragStart: onDragStart,
      onMouseoverSquare: onMouseoverSquare,
      onMouseoutSquare: onMouseoutSquare,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      showNotation: false,
      pieceTheme: useInline
        ? function(piece){ return pieceSvgDataURI(piece); }
        : function(piece){
            const key = String(piece || '').toLowerCase();
            return pieceSet[key] || pieceSvgDataURI(piece);
          }
    };

    if (board) board.destroy();
    const boardEl = document.getElementById('board');
    if (!boardEl) { alert('Board container not found.'); return; }
    if (boardEl.clientWidth === 0) { boardEl.style.width = '480px'; }

    setTimeout(() => {
      const initBoard = () => {
        try {
          board = Chessboard('board', boardConfig);
          boardReadySessionId = gameSessionId;
          // Orient to player's side
          board.orientation(userSide === 'black' ? 'black' : 'white');
          applyBoardHighlights();
          bindBoardTouchInput();
          resetTouchMoveSelection();

          // If AI-vs-AI, schedule first turn immediately.
          if (isAiVsAiActive()) {
            scheduleAiVsAiMove(Math.max(80, aiVsAiMoveDelayMs));
          } else {
            // If user plays Black, let opponent move first
            const myColor = (userSide === 'white') ? 'w' : 'b';
            if (myColor === 'b') {
              if (opponentType === 'stockfish' && sfWorker) {
                try { sfWantGo = true; sfWorker.postMessage('isready'); } catch (_) {}
              }
              setTimeout(() => maybeAIMove(), 250);
            }
          }
        } catch (e) {
          console.error('Chessboard init error after load:', e);
          alert('Chessboard init error: ' + (e && e.message ? e.message : e));
          return;
        }
      };
      if (typeof Chessboard === 'undefined') {
        tryLoadChessboard(initBoard);
      } else {
        initBoard();
      }
    }, 0);
  });

  moveHistory = [game.fen()];
  moveSans = [];
  halfMoveCount = 0;
  gameResultHandled = false;
  gameStatusOverride = null;
  gameRatings = {
    w: { rating: null, accuracy: null, avgCpl: null, moves: 0 },
    b: { rating: null, accuracy: null, avgCpl: null, moves: 0 }
  };
  gameActive = true;
  lastMoveSquares = { from: null, to: null };
  legalTargetSquares = [];
  playerSpecialState = {
    w: { swapUsed:false, shadowCooldown:0, backInTimeUsed:false, resurrectionUsed:false },
    b: { swapUsed:false, shadowCooldown:0, backInTimeUsed:false, resurrectionUsed:false }
  };
  lostPieces = { w: [], b: [] };
  fusionTemp = null;
  doubleMoveUsedBy = {};

  specialStateHistory = [];
  lostPiecesHistory = [];
  pushStateSnapshot();

  refreshSpecialButtons();
  renderMoveHistoryPanel();
  initializeClocks();
  updateTurnInfo();
  updateEloBoardPanel();
  startClockFor(game.turn());
  if (isAiVsAiActive()) {
    log(`Game started in ${modeName.toUpperCase()} mode • AI vs AI (${aiVsAiEngines.w} vs ${aiVsAiEngines.b}) • Level: ${getAiLevelConfig().label}.`);
  } else {
    log(`Game started in ${modeName.toUpperCase()} mode • AI level: ${getAiLevelConfig().label}.`);
  }
}

function onDragStart(source, piece) {
  resetTouchMoveSelection();
  if (isAiVsAiActive()) return false;
  if (!game || !gameActive || game.game_over() || isDemoRunning) return false;
  const turnColor = game.turn();         // 'w' or 'b'
  const myColor = (userSide === 'white') ? 'w' : 'b';
  if (turnColor !== myColor) return false; // only your turn
  if ((myColor === 'w' && piece.startsWith('b')) || (myColor === 'b' && piece.startsWith('w'))) return false; // only your pieces
  showLegalTargets(source);
  return true;
}

function onMouseoverSquare(square, piece) {
  if (!game || !piece || game.game_over()) return;
  const myColor = getUserColorCode();
  if (game.turn() !== myColor) return;
  if ((myColor === 'w' && piece.startsWith('b')) || (myColor === 'b' && piece.startsWith('w'))) return;
  showLegalTargets(square);
}

function onMouseoutSquare() {
  clearLegalTargets();
}

function onDrop(source, target, piece) {
  // On touch devices, a tap can trigger a synthetic drop on the same square.
  // Do not clear tap-selection state for source==target; let tap-to-move continue.
  if (source === target) return 'snapback';
  if (!attemptPlayerMove(source, target)) return 'snapback';
  resetTouchMoveSelection();
  return;
}

function getPromotionChoicesForMove(source, target) {
  if (!game) return [];
  const moves = game.moves({ square: source, verbose: true }) || [];
  const promos = moves
    .filter(m => m && m.to === target && m.promotion)
    .map(m => String(m.promotion).toLowerCase())
    .filter(p => ['q', 'r', 'b', 'n'].includes(p));
  return Array.from(new Set(promos));
}

function promptPromotionChoice(source, target, choices) {
  const opts = Array.isArray(choices) && choices.length ? choices : ['q', 'r', 'b', 'n'];
  const text = `Promote pawn at ${target.toUpperCase()} to (q, r, b, n):`;
  const raw = window.prompt(text, 'q');
  if (raw == null) return null;
  const pick = String(raw).trim().toLowerCase();
  if (opts.includes(pick)) return pick;
  return 'q';
}

function attemptPlayerMove(source, target, forcedPromotion = null) {
  clearLegalTargets();
  const promotionChoices = getPromotionChoicesForMove(source, target);
  let promotion = forcedPromotion;
  if (!promotionChoices.length) promotion = undefined;
  else if (!promotion || !promotionChoices.includes(String(promotion).toLowerCase())) {
    promotion = promptPromotionChoice(source, target, promotionChoices);
    if (!promotion) return false;
  }
  let move = null;
  try {
    const payload = { from: source, to: target };
    if (promotion) payload.promotion = promotion;
    move = game.move(payload);
  } catch (e) { move = null; }
  if (!move) return false;

  trackCapturedFromMove(move);
  // cooldown tick for mover
  tickShadowCooldownFor(move.color);

  halfMoveCount++;
  appendHistoryEntry(move.san);
  board.position(game.fen());
  setLastMove(move.from, move.to);
  log(`${move.color === 'w' ? 'White' : 'Black'}: ${move.san}`);

  // pawn-promotion-on-capture (Mild)
  if (modeConfig && modeConfig.pawnPromotionAnywhere) {
    if (move.flags && move.flags.indexOf('c') !== -1 && move.piece === 'p') {
      setTimeout(() => {
        const choice = prompt('Pawn captured — promote to (q,r,b,n):', 'q');
        const prom = (choice && ['q','r','b','n'].includes(choice.toLowerCase())) ? choice.toLowerCase() : 'q';
        const baseFen = game.fen();
        const bm = fenToBoard(baseFen);
        const pawnChar = (move.color === 'w') ? 'P' : 'p';
        const newChar = (move.color === 'w') ? prom.toUpperCase() : prom.toLowerCase();
        if (bm[target] && bm[target] === pawnChar) {
          bm[target] = newChar;
          const newFen = boardToFen(bm, baseFen, false);
          const testGame = new Chess();
          if (testGame.load(newFen)) {
            game.load(newFen);
            board.position(game.fen());
            setLastMove(move.from, target);
            updateLastMoveText(`${move.from}x${target}=${newChar.toUpperCase()}`);
            log(`Pawn promoted to ${newChar.toUpperCase()} on ${target}`);
          }
        }
      }, 10);
    }
  }

  // random events (Chaotic)
  if (modeConfig && modeConfig.randomEvents) {
    if (halfMoveCount > 0 && halfMoveCount % randomEventInterval === 0) triggerRandomEvent();
  }

  postMoveChecksAndFlow(move.color);
  return true;
}
function onSnapEnd() { board.position(game.fen()); applyBoardHighlights(); }

function resetTouchMoveSelection() {
  touchMoveSource = null;
  removeSquareHighlights();
  clearLegalTargets();
}

function handleTouchSquareTap(square) {
  if (isAiVsAiActive()) return;
  if (!game || !gameActive || game.game_over() || isDemoRunning) return;
  if (squareHandlerBindings.size > 0) return;

  const myColor = getUserColorCode();
  if (game.turn() !== myColor) return;

  const piece = getPieceOnSquare(square);
  const isOwnPiece = piece && ((myColor === 'w' && piece.startsWith('w')) || (myColor === 'b' && piece.startsWith('b')));

  if (!touchMoveSource) {
    if (!isOwnPiece) return;
    touchMoveSource = square;
    showLegalTargets(square);
    highlightSquare(square, true);
    return;
  }

  if (square === touchMoveSource) {
    resetTouchMoveSelection();
    return;
  }

  if (isOwnPiece) {
    resetTouchMoveSelection();
    touchMoveSource = square;
    showLegalTargets(square);
    highlightSquare(square, true);
    return;
  }

  const from = touchMoveSource;
  resetTouchMoveSelection();
  const moved = attemptPlayerMove(from, square);
  if (!moved) {
    touchMoveSource = from;
    showLegalTargets(from);
    highlightSquare(from, true);
  }
}

function onBoardTouchPointerUp(e) {
  if (!e || e.pointerType === 'mouse') return;
  if (squareHandlerBindings.size > 0) return;
  const sqEl = getSquareElementFromInputEvent(e);
  if (!sqEl) return;
  e.preventDefault();
  const sq = sqEl.getAttribute('data-square');
  if (!sq) return;
  handleTouchSquareTap(sq);
}

function onBoardTouchEndFallback(e) {
  if (window.PointerEvent) return;
  if (squareHandlerBindings.size > 0) return;
  const sqEl = getSquareElementFromInputEvent(e);
  if (!sqEl) return;
  e.preventDefault();
  const sq = sqEl.getAttribute('data-square');
  if (!sq) return;
  handleTouchSquareTap(sq);
}

function bindBoardTouchInput() {
  const boardEl = document.getElementById('board');
  if (!boardEl || boardTouchInputBound === boardEl) return;
  if (boardTouchInputBound) {
    boardTouchInputBound.removeEventListener('pointerup', onBoardTouchPointerUp);
    boardTouchInputBound.removeEventListener('touchend', onBoardTouchEndFallback);
  }
  boardEl.addEventListener('pointerup', onBoardTouchPointerUp, { passive: false });
  if (!window.PointerEvent) boardEl.addEventListener('touchend', onBoardTouchEndFallback, { passive: false });
  boardTouchInputBound = boardEl;
}

/* =========================
   Special Moves
   ========================= */
// ---- Swap (Mild)
let swapSelection = [];
function onSwapClick() {
  if (!game) return alert('Start a game first.');
  if (!modeConfig.swapMove) return alert('Swap is disabled in this mode.');
  const player = getUserColorCode();
  if (game.turn() !== player) return alert('You can only use special moves on your turn.');
  if (playerSpecialState[player].swapUsed) return alert('You already used Swap.');
  alert('Swap: click two of your pieces to swap their positions.');

  const handler = (e) => {
    const sq = e.target.getAttribute('data-square'); if (!sq) return;
    const p = getPieceOnSquare(sq); if (!p) return alert('No piece there.');
    if ((player === 'w' && p.startsWith('b')) || (player === 'b' && p.startsWith('w'))) return alert('Pick your own piece.');
    swapSelection.push(sq); highlightSquare(sq, true);
    if (swapSelection.length === 2) {
      const [a, b] = swapSelection;
      const currentFen = game.fen();
      const map = fenToBoard(currentFen);
      const tmp = map[a]; map[a] = map[b]; map[b] = tmp;
      const newFen = boardToFen(map, currentFen, true);
      const test = new Chess();
      if (!test.load(newFen) || test.in_check()) { alert('Swap would create an illegal position.'); clearSwap(handler); return; }
      game.load(newFen); board.position(game.fen());
      setLastMove(a, b);
      playerSpecialState[player].swapUsed = true;
      appendHistoryEntry(`{Swap ${a}<->${b}}`); halfMoveCount++;
      log(`${player === 'w' ? 'White' : 'Black'} used Swap: ${a} ↔ ${b}`);
      clearSwap(handler);
      postMoveChecksAndFlow(player);
    }
  };
  attachSquareClickHandlers(handler);
  function clearSwap(h) { swapSelection = []; removeSquareHighlights(); detachSquareClickHandlers(h); }
}

// ---- Shadow Step (Medium)
function onShadowClick() {
  if (!game) return alert('Start a game first.');
  if (!modeConfig.shadowStep) return alert('Shadow Step is disabled.');
  const player = getUserColorCode();
  if (game.turn() !== player) return alert('You can only use special moves on your turn.');
  if (playerSpecialState[player].shadowCooldown > 0) return alert(`Shadow Step cooldown: ${playerSpecialState[player].shadowCooldown} turn(s) remaining.`);
  alert('Shadow Step: click your piece, then a target square a knight’s move away.');
  const state = { from: null };
  const handler = (e) => {
    const sq = e.target.getAttribute('data-square'); if (!sq) return;
    if (!state.from) {
      const p = getPieceOnSquare(sq); if (!p) return alert('No piece there.');
      if ((player === 'w' && p.startsWith('b')) || (player === 'b' && p.startsWith('w'))) return alert('Pick your own piece.');
      state.from = sq; highlightSquare(sq, true); return;
    } else {
      const from = state.from, to = sq;
      if (!isKnightMove(from, to)) return alert('Target is not a knight move away.');
      const baseFen = game.fen();
      const bm = fenToBoard(baseFen);
      const moving = bm[from]; if (!moving) { alert('No piece at source.'); cleanup(); return; }
      const dest = bm[to];
      if (dest && ((player === 'w' && dest === dest.toUpperCase()) || (player === 'b' && dest === dest.toLowerCase()))) { alert('Cannot land on your own piece.'); cleanup(); return; }
      if (dest) lostPieces[player === 'w' ? 'b' : 'w'].push(dest.toLowerCase());
      bm[to] = moving; bm[from] = null;
      const newFen = boardToFen(bm, baseFen, true);
      const test = new Chess();
      if (!test.load(newFen) || test.in_check()) { alert('Illegal or leaves king in check.'); cleanup(); return; }
      game.load(newFen); board.position(game.fen());
      setLastMove(from, to);
      playerSpecialState[player].shadowCooldown = 5;
      appendHistoryEntry(`{Shadow ${from}-${to}}`); halfMoveCount++;
      log(`${player === 'w' ? 'White' : 'Black'} used Shadow Step: ${from} → ${to}`);
      cleanup();
      postMoveChecksAndFlow(player);
    }
  };
  attachSquareClickHandlers(handler);
  function cleanup() { removeSquareHighlights(); detachSquareClickHandlers(handler); }
}

// ---- Resurrection (Medium)
function onResurrectClick() {
  if (!game) return alert('Start a game first.');
  if (!modeConfig.resurrection) return alert('Resurrection is disabled.');
  const player = getUserColorCode();
  if (game.turn() !== player) return alert('You can only use special moves on your turn.');
  if (playerSpecialState[player].resurrectionUsed) return alert('You already used Resurrection.');
  const pool = getCapturedPieces(player); if (!pool.length) return alert('You have no captured pieces to resurrect.');
  const type = (prompt(`Captured pieces available: ${pool.join(', ')}\nEnter one (q,r,b,n,p):`, 'q')||'').toLowerCase();
  if (!['q','r','b','n','p'].includes(type)) return alert('Invalid piece type.');
  const rankOpts = (player === 'w') ? ['1','2','3'] : ['8','7','6'];
  const sqInput = prompt(`Place on your first three ranks (e.g., a1). Allowed ranks: ${rankOpts.join(',')}`);
  const sq = (sqInput || '').trim().toLowerCase();
  if (!/^[a-h][1-8]$/.test(sq) || !rankOpts.includes(sq[1])) return alert('Invalid square.');
  if (getPieceOnSquare(sq)) return alert('Square not empty.');

  const baseFen = game.fen();
  const bm = fenToBoard(baseFen);
  bm[sq] = (player === 'w') ? type.toUpperCase() : type.toLowerCase();
  const newFen = boardToFen(bm, baseFen, true);
  const test = new Chess();
  if (!test.load(newFen) || test.in_check()) return alert('Illegal resurrection position.');
  game.load(newFen); board.position(game.fen());
  setLastMove(sq, sq);
  playerSpecialState[player].resurrectionUsed = true;
  appendHistoryEntry(`{Resurrect ${type}@${sq}}`); halfMoveCount++;
  log(`${player === 'w' ? 'White' : 'Black'} resurrected ${type.toUpperCase()} on ${sq}`);
  postMoveChecksAndFlow(player);
}

// ---- Back in Time (Chaotic)
function onBackInTimeClick() {
  if (!game) return alert('Start a game first.');
  if (!modeConfig.backInTime) return alert('Back In Time is disabled.');
  const player = getUserColorCode();
  if (game.turn() !== player) return alert('You can only use special moves on your turn.');
  if (playerSpecialState[player].backInTimeUsed) return alert('You already used Back In Time.');
  if (moveHistory.length < 2) return alert('No move to undo.');
  const lastFen = moveHistory[moveHistory.length - 2];
  if (!lastFen) return alert('Cannot undo.');
  game.load(lastFen); board.position(game.fen());
  setLastMove(null, null);
  moveHistory.pop();
  if (moveSans.length) moveSans.pop();
  if (specialStateHistory.length > moveHistory.length) specialStateHistory.pop();
  if (lostPiecesHistory.length > moveHistory.length) lostPiecesHistory.pop();
  restoreStateSnapshotAt(moveHistory.length - 1);
  renderMoveHistoryPanel();
  playerSpecialState[player].backInTimeUsed = true;
  log(`${player === 'w' ? 'White' : 'Black'} used Back In Time.`);
  postMoveChecksAndFlow(player);
}

/* =========================
   Random events (Chaotic)
   ========================= */
function triggerRandomEvent() {
  const events = ['allPawnsAdvance', 'randomPieceSwap', 'rookBecomesQueenOneTurn'];
  const ev = events[Math.floor(Math.random() * events.length)];
  log(`Random Event: ${ev}`);
  if (ev === 'allPawnsAdvance') {
    const positions = game.board();
    const currentFen = game.fen();
    const bm = fenToBoard(currentFen);
    const planned = [];
    const moved = [];
    for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
      const sq = idxToSquare(f, 7 - r); const pieceObj = positions[r][f];
      if (pieceObj && pieceObj.type === 'p') {
        const color = pieceObj.color; const dir = color === 'w' ? 1 : -1;
        const targetRank = parseInt(sq[1]) + dir;
        if (targetRank >= 1 && targetRank <= 8) {
          const targetSquare = sq[0] + targetRank;
          if (!bm[targetSquare]) {
            planned.push({ from: sq, to: targetSquare, color });
          }
        }
      }
    }
    for (const mv of planned) {
      const piece = bm[mv.from];
      if (!piece || bm[mv.to]) continue;
      let movedPiece = piece;
      const toRank = parseInt(mv.to[1], 10);
      if (mv.color === 'w' && toRank === 8) movedPiece = 'Q';
      if (mv.color === 'b' && toRank === 1) movedPiece = 'q';
      bm[mv.to] = movedPiece;
      bm[mv.from] = null;
      moved.push({ from: mv.from, to: mv.to, promoted: movedPiece !== piece });
    }
    if (!moved.length) {
      log('Random: all-pawns-advance had no legal pawn advances.');
    } else {
      const newFen = boardToFen(bm, currentFen, false, { preserveEnPassant: false, resetHalfmove: true });
      const test = new Chess();
      if (test.load(newFen)) {
        game.load(newFen);
        board.position(game.fen());
        if (moved.length) {
          const tail = moved[moved.length - 1];
          setLastMove(tail.from, tail.to);
        }
        moved.forEach(mv => log(`Random: pawn ${mv.from}→${mv.to}${mv.promoted ? ' (promoted)' : ''}`));
        appendHistoryEntry('{Random pawns advance}');
        halfMoveCount += moved.length;
      } else {
        log('Random: all-pawns-advance produced invalid position; skipped.');
      }
    }
  } else if (ev === 'randomPieceSwap') {
    const squares = Object.keys(squareToPieceMapFromFen(game.fen())).filter(sq => getPieceOnSquare(sq));
    if (squares.length >= 2) {
      const a = squares[Math.floor(Math.random()*squares.length)];
      let b = a; while (b === a) b = squares[Math.floor(Math.random()*squares.length)];
      const currentFen = game.fen(); const bm = fenToBoard(currentFen);
      const tmp = bm[a]; bm[a] = bm[b]; bm[b] = tmp;
      const newFen = boardToFen(bm, currentFen, true);
      const test = new Chess();
      if (test.load(newFen)) { game.load(newFen); board.position(game.fen()); setLastMove(a, b); log(`Random: swapped ${a} ↔ ${b}`); appendHistoryEntry(`{Random swap ${a}<->${b}}`); halfMoveCount++; }
      else { log('Random swap illegal; skipped.'); }
    }
  } else if (ev === 'rookBecomesQueenOneTurn') {
    alert('Event: one rook may act like a queen for one move (honor system for this skeleton).');
  }
  updateTurnInfo(); refreshSpecialButtons();
}

/* =========================
   Opponent move (Local greedy or Stockfish)
   ========================= */
function scheduleAiVsAiMove(delayMs = null) {
  clearAiVsAiTimer();
  if (!isAiVsAiActive() || !game || !gameActive || game.game_over() || gameResultHandled || isDemoRunning) return;
  const d = Math.max(40, Number.isFinite(delayMs) ? delayMs : aiVsAiMoveDelayMs);
  aiVsAiTimer = setTimeout(() => runAiVsAiTurn(), d);
}

function runAiVsAiTurn() {
  clearAiVsAiTimer();
  if (!isAiVsAiActive() || !game || !gameActive || game.game_over() || gameResultHandled || isDemoRunning) return;
  const engineForTurn = aiVsAiEngines[game.turn()] || 'local';
  if (engineForTurn === 'stockfish') {
    if (sfDisabled || !sfWorker) {
      aiMoveLocalGreedy();
      return;
    }
    aiMoveStockfish();
  } else {
    aiMoveLocalGreedy();
  }
}

function maybeAIMove() {
  if (isAiVsAiActive()) { runAiVsAiTurn(); return; }
  if (!game || !gameActive) { console.warn('[AI] maybeAIMove called while inactive'); return; }
  if (game.game_over()) { console.log('[AI] Game over, skipping AI move'); return; }
  const myColor = (userSide === 'white') ? 'w' : 'b';
  const oppColor = (myColor === 'w') ? 'b' : 'w';
  const t = game.turn();
  console.log('[AI] maybeAIMove entry', { userSide, myColor, oppColor, turn: t, opponentType });
  if (t !== oppColor) { console.log('[AI] Not opponent turn, exiting'); return; }
  if (opponentType === 'stockfish') {
    console.log('[AI] Routing to Stockfish');
    aiMoveStockfish();
  } else {
    console.log('[AI] Routing to LocalAI');
    aiMoveLocalGreedy();
  }
}

function aiMoveStockfish() {
  console.log('[AI] aiMoveStockfish ENTRY');
  if (!gameActive) return;
  if (sfDisabled) {
    console.warn('Stockfish disabled for this game; using Local AI');
    aiMoveLocalGreedy();
    return;
  }
  if (sfInitInProgress && !sfReady) {
    sfWantGo = true;
    sfLastGoFen = game.fen();
    if (sfWorker) {
      try { sfWorker.postMessage('isready'); } catch (_) {}
    }
    if (sfInitStartedTs && (Date.now() - sfInitStartedTs > 15000)) {
      sfInitInProgress = false;
      forceStockfishFallbackMove('Stockfish startup stalled');
    }
    console.log('[AI] Stockfish still initializing; waiting for readyok');
    return;
  }
  if (!sfWorker) {
    console.warn('Stockfish worker not initialized');
    sfDisabled = true;
    if (!isAiVsAiActive() && opponentType === 'stockfish') {
      opponentType = 'local';
      const oppSel = document.getElementById('opponentSelect');
      if (oppSel) oppSel.value = 'local';
      updateOpponentHint();
      updateTurnInfo();
    }
    log(isAiVsAiActive()
      ? 'Stockfish unavailable for this turn; using Local AI fallback.'
      : 'Stockfish unavailable; switched to Local AI for this game.');
    aiMoveLocalGreedy();
    return;
  }
  const fen = game.fen();
  console.log('[AI] aiMoveStockfish called. sfReady=', sfReady, ' fen=', fen);
  const send = sfWorker._send ? sfWorker._send : (m)=>{ try{ sfWorker.postMessage(m);}catch(e){ console.warn('[SF pm error]', e);} };
  if (sfReady) {
    configureStockfishForLevel(sfWorker);
    sendStockfishGo(sfWorker, fen);
  } else {
    sfInitInProgress = true;
    if (!sfInitStartedTs) sfInitStartedTs = Date.now();
    sfWantGo = true;
    sfLastGoFen = fen;
    send('uci');
    send('ucinewgame');
    send('isready');
    if (sfBestmoveTimer) { clearTimeout(sfBestmoveTimer); sfBestmoveTimer = null; }
    sfBestmoveTimer = setTimeout(() => {
      sfInitInProgress = false;
      forceStockfishFallbackMove('Stockfish init timeout');
    }, 9000);
  }
}

function pieceSquareBonus(type, color, r, f) {
  const rr = (color === 'w') ? (7 - r) : r;
  const centerDist = Math.abs(3.5 - f) + Math.abs(3.5 - rr);
  if (type === 'n' || type === 'b') return Math.round((4.2 - centerDist) * 8);
  if (type === 'q') return Math.round((4.2 - centerDist) * 3);
  if (type === 'r') return Math.round((3.0 - Math.abs(3.5 - rr)) * 2);
  if (type === 'p') return (color === 'w' ? rr : (7 - rr)) * 4 - Math.round(Math.abs(3.5 - f) * 2);
  if (type === 'k') return -Math.round((4.2 - centerDist) * 6);
  return 0;
}

function getKingSquare(color) {
  const b = game.board();
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (p && p.color === color && p.type === 'k') return { r, f };
  }
  return null;
}

function countMobilityFor(color) {
  const parts = game.fen().split(' ');
  parts[1] = color;
  const g = new Chess(parts.join(' '));
  return g.moves().length;
}

function pawnStructureScore() {
  const b = game.board();
  const whitePawnsByFile = Array(8).fill(0);
  const blackPawnsByFile = Array(8).fill(0);
  let score = 0;
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (!p || p.type !== 'p') continue;
    if (p.color === 'w') whitePawnsByFile[f]++; else blackPawnsByFile[f]++;
  }

  for (let f = 0; f < 8; f++) {
    if (whitePawnsByFile[f] > 1) score -= (whitePawnsByFile[f] - 1) * 10;
    if (blackPawnsByFile[f] > 1) score += (blackPawnsByFile[f] - 1) * 10;
  }

  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (!p || p.type !== 'p') continue;
    const isWhite = p.color === 'w';
    const own = isWhite ? whitePawnsByFile : blackPawnsByFile;
    const opp = isWhite ? blackPawnsByFile : whitePawnsByFile;
    const isolated = (f === 0 || own[f - 1] === 0) && (f === 7 || own[f + 1] === 0);
    if (isolated) score += isWhite ? -12 : 12;

    let passed = true;
    const rankForwardStart = isWhite ? (7 - r + 1) : (r + 1);
    for (let ff = Math.max(0, f - 1); ff <= Math.min(7, f + 1); ff++) {
      if (opp[ff] > 0) {
        const hasBlocking = (() => {
          for (let rr = 0; rr < 8; rr++) {
            const q = b[rr][ff];
            if (!q || q.type !== 'p' || q.color === p.color) continue;
            const qForward = isWhite ? (7 - rr + 1) : (rr + 1);
            if (qForward >= rankForwardStart) return true;
          }
          return false;
        })();
        if (hasBlocking) { passed = false; break; }
      }
    }
    if (passed) score += isWhite ? 18 : -18;
  }
  return score;
}

function kingSafetyScore() {
  const b = game.board();
  const wk = getKingSquare('w');
  const bk = getKingSquare('b');
  let score = 0;
  const shield = (k, color) => {
    if (!k) return 0;
    const dir = color === 'w' ? -1 : 1;
    let s = 0;
    for (let df = -1; df <= 1; df++) {
      const rr = k.r + dir;
      const ff = k.f + df;
      if (rr < 0 || rr > 7 || ff < 0 || ff > 7) continue;
      const p = b[rr][ff];
      if (p && p.type === 'p' && p.color === color) s += 8;
      else s -= 6;
    }
    return s;
  };
  score += shield(wk, 'w');
  score -= shield(bk, 'b');
  return score;
}

function evaluatePositionForSideToMove() {
  if (game.in_checkmate()) return -100000;
  if (game.in_stalemate() || game.in_draw() || game.in_threefold_repetition()) return 0;
  const values = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
  let evalWhite = 0;
  const b = game.board();
  for (let r = 0; r < 8; r++) for (let f = 0; f < 8; f++) {
    const p = b[r][f];
    if (!p) continue;
    const base = values[p.type] || 0;
    const pst = pieceSquareBonus(p.type, p.color, r, f);
    const val = base + pst;
    evalWhite += (p.color === 'w') ? val : -val;
  }
  const mobilityW = countMobilityFor('w');
  const mobilityB = countMobilityFor('b');
  evalWhite += (mobilityW - mobilityB) * 3;
  evalWhite += pawnStructureScore();
  evalWhite += kingSafetyScore();
  return game.turn() === 'w' ? evalWhite : -evalWhite;
}

function scoreMoveForOrdering(m) {
  const victim = m.captured ? ({ p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 }[m.captured] || 0) : 0;
  const attacker = ({ p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 }[m.piece] || 0);
  let score = 0;
  if (m.captured) score += 10 * victim - attacker;
  if (m.promotion) score += 750;
  if (m.flags && m.flags.indexOf('e') !== -1) score += 105;
  if (m.flags && m.flags.indexOf('k') !== -1) score += 40;
  if (m.flags && m.flags.indexOf('q') !== -1) score += 35;
  return score;
}

function orderedMoves(moves, pvMoveKey = '') {
  const scored = [];
  for (const m of moves) {
    const key = m.from + m.to + (m.promotion || '');
    let score = scoreMoveForOrdering(m);
    if (pvMoveKey && key === pvMoveKey) score += 1000000;
    scored.push({ m, score });
  }
  scored.sort((a, b) => b.score - a.score);
  return scored.map(x => x.m);
}

function quiescence(alpha, beta, depth = 0) {
  if (searchTimedOut()) { searchAbortFlag = true; return evaluatePositionForSideToMove(); }
  const standPat = evaluatePositionForSideToMove();
  if (standPat >= beta) return beta;
  if (alpha < standPat) alpha = standPat;
  if (depth >= 8) return standPat;

  const tactical = orderedMoves(game.moves({ verbose: true }).filter(m => m.captured || m.promotion || (m.flags && m.flags.indexOf('e') !== -1)));
  for (const m of tactical) {
    if (searchTimedOut()) { searchAbortFlag = true; break; }
    game.move(m);
    const score = -quiescence(-beta, -alpha, depth + 1);
    game.undo();
    if (score >= beta) return beta;
    if (score > alpha) alpha = score;
  }
  return alpha;
}

function negamax(depth, alpha, beta) {
  if (searchTimedOut()) { searchAbortFlag = true; return evaluatePositionForSideToMove(); }
  if (depth <= 0) return quiescence(alpha, beta, 0);
  if (game.game_over()) return evaluatePositionForSideToMove();
  const alphaOrig = alpha;
  const fen = game.fen();
  const tt = ttGet(fen);
  if (tt && tt.depth >= depth) {
    if (tt.flag === 'EXACT') return tt.score;
    if (tt.flag === 'LOWER') alpha = Math.max(alpha, tt.score);
    else if (tt.flag === 'UPPER') beta = Math.min(beta, tt.score);
    if (alpha >= beta) return tt.score;
  }
  const pvMoveKey = tt && tt.bestMoveKey ? tt.bestMoveKey : '';
  const moves = orderedMoves(game.moves({ verbose: true }), pvMoveKey);
  if (!moves.length) return evaluatePositionForSideToMove();
  let best = -Infinity;
  let bestMoveKey = '';
  for (const m of moves) {
    if (searchTimedOut()) { searchAbortFlag = true; break; }
    game.move(m);
    const score = -negamax(depth - 1, -beta, -alpha);
    game.undo();
    if (score > best) {
      best = score;
      bestMoveKey = m.from + m.to + (m.promotion || '');
    }
    if (score > alpha) alpha = score;
    if (alpha >= beta) break;
  }
  if (best !== -Infinity) {
    let flag = 'EXACT';
    if (best <= alphaOrig) flag = 'UPPER';
    else if (best >= beta) flag = 'LOWER';
    ttSet(fen, { depth, score: best, flag, bestMoveKey });
  }
  return best;
}

function pickOpeningBookMove() {
  if (!game || modeName !== 'classic') return null;
  const hist = game.history({ verbose: true }).map(m => m.from + m.to + (m.promotion || ''));
  if (hist.length >= 12) return null;
  const candidates = [];
  for (const line of openingBookLines) {
    let ok = true;
    for (let i = 0; i < hist.length; i++) {
      if (line[i] !== hist[i]) { ok = false; break; }
    }
    if (ok && line[hist.length]) candidates.push(line[hist.length]);
  }
  if (!candidates.length) return null;
  const target = candidates[Math.floor(Math.random() * candidates.length)];
  const legal = game.moves({ verbose: true });
  return legal.find(m => (m.from + m.to + (m.promotion || '')) === target) || null;
}

function pickLocalMoveByLevel() {
  const legal = game.moves({ verbose: true });
  if (!legal.length) return null;

  const bookMove = pickOpeningBookMove();
  if (bookMove) return bookMove;

  const cfg = getAiLevelConfig().local;
  const maxDepth = Math.max(1, cfg.depth | 0);
  const budgetMs = getLocalAiTimeBudgetByLevel();
  resetSearchContext(budgetMs, true);

  let rootMoves = orderedMoves(legal);
  let bestAny = null;
  let bestCompleted = null;
  let lastScored = null;

  for (let depth = 1; depth <= maxDepth; depth++) {
    if (searchTimedOut()) break;
    if (bestCompleted && bestCompleted.m) {
      const pv = bestCompleted.m.from + bestCompleted.m.to + (bestCompleted.m.promotion || '');
      rootMoves = orderedMoves(rootMoves, pv);
    }
    const scored = [];
    let best = null;
    let bestScore = -Infinity;
    for (const m of rootMoves) {
      if (searchTimedOut()) { searchAbortFlag = true; break; }
      game.move(m);
      const score = -negamax(depth - 1, -Infinity, Infinity);
      game.undo();
      scored.push({ m, score });
      if (score > bestScore) {
        bestScore = score;
        best = m;
      }
    }
    if (best) bestAny = { m: best, score: bestScore, depth };
    if (best && !searchAbortFlag) bestCompleted = { m: best, score: bestScore, depth };
    if (scored.length) {
      lastScored = scored;
      lastScored.sort((a, b) => b.score - a.score);
    }
    if (searchAbortFlag) break;
  }

  endSearchContext();
  if (!bestAny) return rootMoves[0] || null;

  if (lastScored && Math.random() < cfg.blunderRate && lastScored.length > 1) {
    const worstBandStart = Math.max(1, Math.floor(lastScored.length * 0.7));
    const idx = worstBandStart + Math.floor(Math.random() * (lastScored.length - worstBandStart));
    return lastScored[idx].m;
  }

  const chosen = (bestCompleted && bestCompleted.m) ? bestCompleted.m : bestAny.m;
  if (cfg.randomness > 0 && lastScored && lastScored.length > 1) {
    // Keep Master nearly deterministic while preserving slight variety at lower levels.
    const gap = lastScored[0].score - lastScored[1].score;
    if (gap < (20 + cfg.randomness * 50) && Math.random() < Math.min(0.2, cfg.randomness * 0.2)) {
      return lastScored[1].m;
    }
  }
  return chosen;
}

function aiMoveLocalGreedy() {
  const best = pickLocalMoveByLevel();
  if (!best) return;
  const mv = game.move(best);
  trackCapturedFromMove(mv);
  tickShadowCooldownFor(mv.color);
  board.position(game.fen());
  setLastMove(mv.from, mv.to);
  appendHistoryEntry(mv.san);
  halfMoveCount++;
  log(`Opponent (${getAiLevelConfig().label}): ${best.san}`);
  postMoveChecksAndFlow(mv.color);
}

/* =========================
   Scripted demo (all special moves)
   ========================= */
function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

function setControlsDisabled(disabled) {
  ['startBtn','resignBtn','resetBtn','demoBtn','undoBtn','rematchBtn','exportPgnBtn','modeSelect','gameTypeSelect','sideSelect','opponentSelect','aiWhiteEngineSelect','aiBlackEngineSelect','aiVsAiSpeedSelect','levelSelect','helpSelect','timeControlSelect','askHelpBtn','replayStartBtn','replayPrevBtn','replayNextBtn','replayPlayBtn','replayPauseBtn','replayEndBtn'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = !!disabled;
  });
  document.querySelectorAll('#specialButtons button').forEach(el => { el.disabled = !!disabled; });
  const yes = document.getElementById('demoYesBtn');
  const no = document.getElementById('demoNoBtn');
  if (yes) yes.disabled = false;
  if (no) no.disabled = false;
}

function startScenario(mode) {
  const modeSel = document.getElementById('modeSelect');
  const gameTypeSelEl = document.getElementById('gameTypeSelect');
  const sideSel = document.getElementById('sideSelect');
  const oppSel = document.getElementById('opponentSelect');
  if (modeSel) modeSel.value = mode;
  if (gameTypeSelEl) gameTypeSelEl.value = 'human_vs_ai';
  if (sideSel) sideSel.value = 'white';
  if (oppSel) oppSel.value = 'local';
  startGame();
}

async function waitForBoardReady(timeoutMs = 4000) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    if (game && board && typeof board.position === 'function' && boardReadySessionId === gameSessionId) return true;
    await sleep(50);
  }
  return false;
}

function setDemoPosition(fen) {
  if (!game || !board || typeof board.position !== 'function') return false;
  const ok = game.load(fen);
  if (!ok) return false;
  board.position(game.fen());
  setLastMove(null, null);
  moveHistory = [game.fen()];
  moveSans = [];
  specialStateHistory = [];
  lostPiecesHistory = [];
  pushStateSnapshot();
  halfMoveCount = 0;
  renderMoveHistoryPanel();
  updateTurnInfo();
  refreshSpecialButtons();
  return true;
}

function playDemoMove(from, to, promotion) {
  const mv = game.move({ from, to, promotion: promotion || 'q' });
  if (!mv) return false;
  trackCapturedFromMove(mv);
  tickShadowCooldownFor(mv.color);
  board.position(game.fen());
  setLastMove(mv.from, mv.to);
  appendHistoryEntry(mv.san);
  halfMoveCount++;
  log(`Demo move: ${mv.san}`);
  postMoveChecksAndFlow(mv.color);
  return true;
}

function playDemoSwap(a, b, player = 'w') {
  const currentFen = game.fen();
  const map = fenToBoard(currentFen);
  if (!map[a] || !map[b]) return false;
  const tmp = map[a]; map[a] = map[b]; map[b] = tmp;
  const newFen = boardToFen(map, currentFen, true);
  const test = new Chess();
  if (!test.load(newFen) || test.in_check()) return false;
  game.load(newFen);
  board.position(game.fen());
  setLastMove(a, b);
  playerSpecialState[player].swapUsed = true;
  appendHistoryEntry(`{Demo Swap ${a}<->${b}}`);
  halfMoveCount++;
  log(`Demo special: Swap ${a} ↔ ${b}`);
  postMoveChecksAndFlow(player);
  return true;
}

function playDemoPawnCapturePromotion(from, to, promoteTo = 'q') {
  const mv = game.move({ from, to, promotion: 'q' });
  if (!mv || mv.piece !== 'p' || !mv.captured) return false;
  trackCapturedFromMove(mv);
  tickShadowCooldownFor(mv.color);
  const baseFen = game.fen();
  const bm = fenToBoard(baseFen);
  bm[to] = mv.color === 'w' ? promoteTo.toUpperCase() : promoteTo.toLowerCase();
  const newFen = boardToFen(bm, baseFen, false);
  if (!game.load(newFen)) return false;
  board.position(game.fen());
  setLastMove(from, to);
  appendHistoryEntry(`{Demo PawnPromo ${from}x${to}}`);
  halfMoveCount++;
  log(`Demo special: Pawn captured on ${to} and promoted to ${promoteTo.toUpperCase()}`);
  postMoveChecksAndFlow(mv.color);
  return true;
}

function playDemoShadowStep(from, to, player = 'w') {
  const baseFen = game.fen();
  const bm = fenToBoard(baseFen);
  const moving = bm[from];
  if (!moving || !isKnightMove(from, to)) return false;
  const dest = bm[to];
  if (dest && ((player === 'w' && dest === dest.toUpperCase()) || (player === 'b' && dest === dest.toLowerCase()))) return false;
  if (dest) lostPieces[player === 'w' ? 'b' : 'w'].push(dest.toLowerCase());
  bm[to] = moving; bm[from] = null;
  const newFen = boardToFen(bm, baseFen, true);
  const test = new Chess();
  if (!test.load(newFen) || test.in_check()) return false;
  game.load(newFen);
  board.position(game.fen());
  setLastMove(from, to);
  playerSpecialState[player].shadowCooldown = 5;
  appendHistoryEntry(`{Demo Shadow ${from}-${to}}`);
  halfMoveCount++;
  log(`Demo special: Shadow Step ${from} → ${to}`);
  postMoveChecksAndFlow(player);
  return true;
}

function playDemoResurrection(pieceType, square, player = 'w') {
  const baseFen = game.fen();
  const bm = fenToBoard(baseFen);
  if (bm[square]) return false;
  bm[square] = player === 'w' ? pieceType.toUpperCase() : pieceType.toLowerCase();
  const newFen = boardToFen(bm, baseFen, true);
  const test = new Chess();
  if (!test.load(newFen) || test.in_check()) return false;
  game.load(newFen);
  board.position(game.fen());
  setLastMove(square, square);
  playerSpecialState[player].resurrectionUsed = true;
  appendHistoryEntry(`{Demo Resurrect ${pieceType}@${square}}`);
  halfMoveCount++;
  log(`Demo special: Resurrection ${pieceType.toUpperCase()} on ${square}`);
  postMoveChecksAndFlow(player);
  return true;
}

function playDemoBackInTime(player = 'w') {
  if (moveHistory.length < 2) return false;
  const lastFen = moveHistory[moveHistory.length - 2];
  if (!lastFen || !game.load(lastFen)) return false;
  board.position(game.fen());
  setLastMove(null, null);
  moveHistory.pop();
  if (moveSans.length) moveSans.pop();
  if (specialStateHistory.length > moveHistory.length) specialStateHistory.pop();
  if (lostPiecesHistory.length > moveHistory.length) lostPiecesHistory.pop();
  restoreStateSnapshotAt(moveHistory.length - 1);
  renderMoveHistoryPanel();
  playerSpecialState[player].backInTimeUsed = true;
  log('Demo special: Back In Time (opponent move undone)');
  postMoveChecksAndFlow(player);
  return true;
}

async function runSpecialMovesDemo() {
  if (isDemoRunning) return;
  isDemoRunning = true;
  stopClockTicker();
  updateClockUI(null);
  setControlsDisabled(true);
  closeDemoOverlay();

  try {
    log('Demo start: interactive walkthrough of all special moves.');
    const steps = [
      {
        mode: 'mild',
        fen: '4k3/8/8/8/8/8/8/R3K1NR w KQ - 0 1',
        from: 'a1',
        to: 'g1',
        title: 'Swap (Mild)',
        body: 'Swap lets you choose two of your own pieces and instantly exchange their squares.',
        moveText: 'Demo move: a1 ↔ g1',
        resultBody: 'Result: the rook and knight exchanged squares instantly.',
        execute: () => playDemoSwap('a1', 'g1', 'w')
      },
      {
        mode: 'mild',
        fen: '4k3/8/5p2/4P3/8/8/8/4K3 w - - 0 1',
        from: 'e5',
        to: 'f6',
        title: 'Pawn Capture Promotion (Mild)',
        body: 'When a pawn captures, it can promote immediately on that destination square.',
        moveText: 'Demo move: e5xf6 then promote to Queen',
        resultBody: 'Result: the pawn captured on f6 and became a queen on the same square.',
        execute: () => playDemoPawnCapturePromotion('e5', 'f6', 'q')
      },
      {
        mode: 'medium',
        fen: '4k3/8/8/3p4/8/2N5/8/4K3 w - - 0 1',
        from: 'c3',
        to: 'd5',
        title: 'Shadow Step (Medium)',
        body: 'Shadow Step lets any chosen piece blink to a square that is a knight move away, as long as the result is legal.',
        moveText: 'Demo move: c3 → d5 (knight-shape blink)',
        resultBody: 'Result: the piece blinked from c3 to d5 in one special move.',
        execute: () => playDemoShadowStep('c3', 'd5', 'w')
      },
      {
        mode: 'medium',
        fen: '4k3/8/8/8/8/8/8/4K3 w - - 0 1',
        from: 'b1',
        to: 'b1',
        title: 'Resurrection (Medium)',
        body: 'Resurrection returns one previously lost piece to an empty square on your first three ranks.',
        moveText: 'Demo move: resurrect Knight on b1',
        resultBody: 'Result: a captured knight was restored to b1.',
        setup: () => { lostPieces.w = ['n']; },
        execute: () => playDemoResurrection('n', 'b1', 'w')
      },
      {
        mode: 'chaotic',
        fen: '4k3/8/8/8/8/8/4P3/4K3 w - - 0 1',
        from: 'e8',
        to: 'e7',
        title: 'Back In Time (Chaotic)',
        body: 'Back In Time rewinds the opponent’s most recent move, restoring the previous board state.',
        moveText: 'Setup move first: ...Ke7, then rewind it',
        resultBody: 'Result: the opponent’s last move was undone and the prior position returned.',
        setup: () => {
          if (!playDemoMove('e2', 'e4')) return false;
          if (!playDemoMove('e8', 'e7')) return false;
          return true;
        },
        execute: () => playDemoBackInTime('w'),
        afterText: 'Back In Time activated: Black’s last move was undone.'
      }
    ];

    for (let i = 0; i < steps.length; i++) {
      const s = steps[i];
      startScenario(s.mode);
      if (!(await waitForBoardReady())) throw new Error(`Board did not initialize for ${s.mode} demo.`);
      if (!setDemoPosition(s.fen)) throw new Error(`Could not load demo position for ${s.title}.`);
      if (typeof s.setup === 'function') {
        const setupOk = s.setup();
        if (setupOk === false) throw new Error(`${s.title} setup failed.`);
      }
      const proceed = await askDemoStepOnBoard({
        title: `${s.title} — Before`,
        body: `${s.body} The board currently shows the position before the special move.`,
        moveText: s.moveText,
        question: `Show the after-move result now? (${i + 1}/${steps.length})`,
        yesLabel: 'Show After Move',
        noLabel: 'Stop Demo'
      });
      if (!proceed) {
        log('Demo stopped by user.');
        closeDemoOverlay();
        return;
      }

      clearDemoPreview();
      const ok = s.execute();
      if (!ok) throw new Error(`${s.title} demo move failed.`);
      if (s.afterText) log(s.afterText);

      const pauseBeforeNext = await askDemoStepOnBoard({
        title: `${s.title} — Result`,
        body: s.resultBody || 'Result shown on board.',
        moveText: `Current board shows the result of move ${i + 1}/${steps.length}.`,
        question: (i < steps.length - 1)
          ? 'Continue to the next special move?'
          : 'All moves shown. Close demo?',
        yesLabel: (i < steps.length - 1) ? 'Next Before Position' : 'Close',
        noLabel: 'Stop Demo'
      });
      if (!pauseBeforeNext) {
        log('Demo stopped by user after reviewing move result.');
        closeDemoOverlay();
        return;
      }
    }
    closeDemoOverlay();
    log('Demo complete. All special moves shown.');
  } catch (err) {
    console.error(err);
    closeDemoOverlay();
    log(`Demo error: ${err && err.message ? err.message : err}`);
    alert(`Demo stopped: ${err && err.message ? err.message : err}`);
  } finally {
    isDemoRunning = false;
    setControlsDisabled(false);
    updateTurnInfo();
    refreshSpecialButtons();
    if (gameActive && game && !game.game_over()) startClockFor(game.turn());
  }
}

/* =========================
   Utilities
   ========================= */
function getPieceOnSquare(square) {
  const b = game.board();
  const fileIdx = square.charCodeAt(0) - 97;
  const rank = parseInt(square[1]);
  const row = 8 - rank;
  const p = b[row][fileIdx];
  if (!p) return null;
  return (p.color === 'w' ? 'w' : 'b') + p.type;
}
function getCapturedPieces(playerColor) { return lostPieces[playerColor].slice(); }
function escapeHtml(value) {
  return String(value == null ? '' : value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
function getSquareElementFromInputEvent(e) {
  if (!e) return null;
  let target = null;
  if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
    target = document.elementFromPoint(e.clientX, e.clientY);
  } else if (e.changedTouches && e.changedTouches.length) {
    const t = e.changedTouches[0];
    target = document.elementFromPoint(t.clientX, t.clientY);
  } else {
    target = e.target || null;
  }
  return target && target.closest ? target.closest('[data-square]') : null;
}
function isKnightMove(from, to) {
  const fx = from.charCodeAt(0), fy = parseInt(from[1],10);
  const tx = to.charCodeAt(0), ty = parseInt(to[1],10);
  const dx = Math.abs(fx - tx), dy = Math.abs(fy - ty);
  return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
}
function attachSquareClickHandlers(handler) {
  if (!handler || squareHandlerBindings.has(handler)) return;
  const clickWrapper = (e) => {
    const sqEl = getSquareElementFromInputEvent(e);
    if (!sqEl) return;
    handler({ target: sqEl, originalEvent: e });
  };
  const pointerWrapper = (e) => {
    if (!e || e.pointerType === 'mouse') return;
    const sqEl = getSquareElementFromInputEvent(e);
    if (!sqEl) return;
    e.preventDefault();
    handler({ target: sqEl, originalEvent: e });
  };
  squareHandlerBindings.set(handler, { clickWrapper, pointerWrapper });
  document.querySelectorAll('[data-square]').forEach(el => {
    el.addEventListener('click', clickWrapper);
    el.addEventListener('pointerup', pointerWrapper, { passive: false });
  });
}

function detachSquareClickHandlers(handler) {
  const bound = squareHandlerBindings.get(handler);
  if (!bound) return;
  document.querySelectorAll('[data-square]').forEach(el => {
    el.removeEventListener('click', bound.clickWrapper);
    el.removeEventListener('pointerup', bound.pointerWrapper);
  });
  squareHandlerBindings.delete(handler);
}

function clearSquareInteractionHandlers() {
  const squares = document.querySelectorAll('[data-square]');
  squareHandlerBindings.forEach((bound) => {
    squares.forEach(el => {
      el.removeEventListener('click', bound.clickWrapper);
      el.removeEventListener('pointerup', bound.pointerWrapper);
    });
  });
  squareHandlerBindings.clear();
}
function highlightSquare(sq, on=true) { const el = document.querySelector(`[data-square='${sq}']`); if (el) el.classList.toggle('hl', !!on); }
function removeSquareHighlights() { document.querySelectorAll('[data-square].hl').forEach(el => el.classList.remove('hl')); }
function fenToBoard(fen) {
  const parts = fen.split(' '); const rows = parts[0].split('/'); const map = {};
  for (let rank = 8; rank >= 1; rank--) {
    const rowStr = rows[8 - rank]; let fileIdx = 0;
    for (let i = 0; i < rowStr.length; i++) {
      const ch = rowStr[i];
      if (/\d/.test(ch)) { const empties = parseInt(ch, 10); for (let k = 0; k < empties; k++) { const sq = String.fromCharCode(97 + fileIdx) + String(rank); map[sq] = null; fileIdx++; } }
      else { const sq = String.fromCharCode(97 + fileIdx) + String(rank); map[sq] = ch; fileIdx++; }
    }
  }
  return map;
}
function boardToFen(boardMap, baseFen, flipTurn = false, options = {}) {
  const parts = String(baseFen || '').split(' ');
  const originalTurn = (parts[1] === 'b') ? 'b' : 'w';
  let ranks = [];
  for (let rank = 8; rank >= 1; rank--) {
    let row = '', empty = 0;
    for (let file = 0; file < 8; file++) {
      const sq = String.fromCharCode(97 + file) + String(rank);
      const v = boardMap[sq];
      if (!v) { empty++; } else { if (empty > 0) { row += empty; empty = 0; } row += v; }
    }
    if (empty > 0) row += empty; ranks.push(row);
  }
  const turn = flipTurn ? (originalTurn === 'w' ? 'b' : 'w') : originalTurn;
  const preserveCastling = options.preserveCastling !== false;
  const preserveEnPassant = options.preserveEnPassant !== false;
  const resetHalfmove = !!options.resetHalfmove;
  const castling = sanitizeCastlingRights(boardMap, parts[2] || '-');
  const ep = preserveEnPassant ? sanitizeEnPassantSquare(parts[3] || '-', boardMap, turn) : '-';
  const halfmove = resetHalfmove ? '0' : String(parseInt(parts[4] || '0', 10) || 0);
  const fullmoveNum = parseInt(parts[5] || '1', 10);
  const fullmove = String(flipTurn && originalTurn === 'b' ? fullmoveNum + 1 : fullmoveNum);
  return ranks.join('/') + ' ' + turn + ' ' + (preserveCastling ? castling : '-') + ' ' + ep + ' ' + halfmove + ' ' + fullmove;
}

function sanitizeCastlingRights(boardMap, baseRights) {
  const rights = String(baseRights || '-');
  let out = '';
  if (rights.includes('K') && boardMap.e1 === 'K' && boardMap.h1 === 'R') out += 'K';
  if (rights.includes('Q') && boardMap.e1 === 'K' && boardMap.a1 === 'R') out += 'Q';
  if (rights.includes('k') && boardMap.e8 === 'k' && boardMap.h8 === 'r') out += 'k';
  if (rights.includes('q') && boardMap.e8 === 'k' && boardMap.a8 === 'r') out += 'q';
  return out || '-';
}

function sanitizeEnPassantSquare(epSquare, boardMap, sideToMove) {
  const ep = String(epSquare || '-');
  if (ep === '-') return '-';
  if (!/^[a-h][36]$/.test(ep)) return '-';
  if (boardMap[ep]) return '-';

  const file = ep.charCodeAt(0);
  const rank = parseInt(ep[1], 10);
  const left = String.fromCharCode(file - 1) + String(sideToMove === 'w' ? 5 : 4);
  const right = String.fromCharCode(file + 1) + String(sideToMove === 'w' ? 5 : 4);
  const capturer = sideToMove === 'w' ? 'P' : 'p';
  const hasCapturer = (file > 97 && boardMap[left] === capturer) || (file < 104 && boardMap[right] === capturer);
  if (!hasCapturer) return '-';

  const passedPawnSquare = ep[0] + String(rank + (sideToMove === 'w' ? -1 : 1));
  const passedPawn = sideToMove === 'w' ? 'p' : 'P';
  if (boardMap[passedPawnSquare] !== passedPawn) return '-';

  return ep;
}
function squareToPieceMapFromFen(fen) {
  const g = new Chess(fen); const arr = g.board(); const map = {};
  for (let r=0;r<8;r++) for (let f=0;f<8;f++) {
    const sq = String.fromCharCode(97+f) + String(8-r); const p = arr[r][f];
    if (p) map[sq] = (p.color==='w' ? p.type.toUpperCase() : p.type.toLowerCase());
  }
  return map;
}
function idxToSquare(fileIdx, rankIdx) { const file = String.fromCharCode(97 + fileIdx); const rank = String(1 + rankIdx); return file + rank; }

async function checkAssetUrl(url) {
  try {
    const r = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    if (r && r.ok) return true;
  } catch (_) {}
  try {
    const r2 = await fetch(url, { cache: 'no-store' });
    return !!(r2 && r2.ok);
  } catch (_) {}
  return false;
}

async function runAssetCheck() {
  const el = document.getElementById('assetCheckResult');
  if (!el) return;
  const required = [
    './vendor/jquery.min.js',
    './vendor/chessboard-0.3.0.min.css',
    './vendor/chessboard-0.3.0.min.js',
    './vendor/chess.min.js',
    './stockfish.js',
    './stockfish.wasm',
    './stockfish-nnue-16-single.wasm',
    './vendor/pieces/wp.svg',
    './vendor/pieces/wr.svg',
    './vendor/pieces/wn.svg',
    './vendor/pieces/wb.svg',
    './vendor/pieces/wq.svg',
    './vendor/pieces/wk.svg',
    './vendor/pieces/bp.svg',
    './vendor/pieces/br.svg',
    './vendor/pieces/bn.svg',
    './vendor/pieces/bb.svg',
    './vendor/pieces/bq.svg',
    './vendor/pieces/bk.svg'
  ];
  el.classList.remove('asset-ok', 'asset-missing');
  el.textContent = 'Checking...';
  const missing = [];
  for (const url of required) {
    const ok = await checkAssetUrl(url);
    if (!ok) missing.push(url.replace(/^\.\//, ''));
  }
  if (!missing.length) {
    el.textContent = 'OK';
    el.classList.add('asset-ok');
  } else {
    el.textContent = `Missing: ${missing.join(', ')}`;
    el.classList.add('asset-missing');
  }
}

/* =========================
   Boot
   ========================= */
if (gameTypeSel) gameType = gameTypeSel.value || 'human_vs_ai';
if (aiWhiteSel) aiVsAiEngines.w = aiWhiteSel.value || 'local';
if (aiBlackSel) aiVsAiEngines.b = aiBlackSel.value || 'local';
if (aiVsAiSpeedSel) aiVsAiMoveDelayMs = parseInt(aiVsAiSpeedSel.value || '500', 10) || 500;
updateGameTypeUI();
setupBoardLabels();
setupDemoOverlayDrag();
hideEndgameOverlay();
updateOpponentHint();
updateTurnInfo();
updateEloBoardPanel();
updateHelpInfo();
updateReplayControlsState();
runAssetCheck();
log('Loaded. Choose a mode and click "Start Game".');
</script>
</body>
</html>
